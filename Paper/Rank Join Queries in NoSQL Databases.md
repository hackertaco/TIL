# 23/01/02
한줄 평:

Rank(top-k)조인 쿼리는 최신 분석 업무에 중요한 역할을 하지만, 간과되곤 한다.
따라서 이 간극을 좁혀보고자 한다: 전체적으로 퍼포먼스를 연구하는 것이다.

첫째로 맵 리듀스나 조정 전략을 사용해 접근될 전문적인 색인에 기반하여 솔루션을 제시한다. 

둘째로, 중앙집중된 랭크 조인 알고리즘을 접목시킨다.

조금 더 나아가 신기한 통계적 구조를 공헌한다. 

- 제공하는 것
  - 어떻게 이 색인과 통계 구조를 지을지 보여주는 맵리듀스
  - 이 색인을 온라인 업데이트 허용 알고리즘
  - 그를 이용하는 쿼리 프로세싱 알고리즘 
모든 하둡의 알고리즘을 시행했고, TPC-H 데이터셋에서 그들을 실험했다. 

## Introduction
클라우스 스토어는 매우 다양한 빅데이터 제공자, 소비자 등의 선택을 받게 되었다. 
기존의 RDBMS는 아무래도 스케일을 크게 할 수가 없어, NoSQL, MapReduce 프레임워크 기술이 생겼다.

이 기술들은 상당한 수의 서버를 스케일링하고, 장애를 견딜 수 있고, 높은 write 이용률과 낮은 read 지연을 위해 만들어졌다.

이 NoSQL DB는 key-value 모델로 보여질 수 있는데, 네개의 코어 추상화로 이루어져있다.
1) key-value pair: key, 컬럼명, 컬럼 값, 타임스탬프
2) table: key-value pairs의 정리된 컬렉션
3) row: 모든 주어진 컬렉션. 같은 키를 공유한다.
더 나아가 몇몇은 컬럼 family라는 개념도 추가한다. 이는 본질적으로 특정 컬럼명에 key-value 짝을 포함하게끔 테이블 데이터를 수직으로 나누는 개념이다.

이러한 모든 시스템은 효율적인 쿼리와 순차적인 스캔이 필요하지만, 비용이 든다. 

처음의 의도에도 불구하고, NoSQL은 재세례 받았다. "SQL 뿐만 아니라"로.
더 많은 데이터가 이 시스템에 들어올 때마다, 더 복잡한 쿼리에 대한 니즈가 생겼다. 
이는 점점 비정규화에 대한 단점 실현으로 갔다. 

NoSQL이 빠른 keyed-row 회수를 보장하지만, 이 행들은 대부분의 쿼리에서 필요없는 데이를 포함했고, 좋지않은 쿼리 성능을 보였다.
따라서, NoSQL은 몇몇 테이블을 포함하도록 변경되었으며, 외래키와 비슷한 구조로 연결되고, 쿼리 시간에 조인되었다. 
문제는 애플리케이션에 이를 처리하는 일이다. 

#### 동기
조인은 자원이 매우 부족하기 때문에, 최근의 연구는 그를 클라우드에서 사용하려고 했다.
지금까지, 랭크된 조인은 완전히 이 세팅에서 간과되었다. 이 쿼리가 다양한 상황에서 나온다는 사실에도 불구하고. 

### 문제 형성
무공유 분산 클라우드 스토어에서 작업을 한다고 가정해본다.
파일 시스템 혹은 NoSQL 어디든 테이블이 저장되어있다. 

각 행을 점수내는 것은 미리 설정된 함수나 명확한 점수 속성이다. 
우리는 이 점수 속성이 0에서 1 사이에 잇다고 가정한다. 그는 확실해야한다. 

그 다음에, 이 점수들은 f()에 의하여 계산된다.
순수하게는 조인 결과를 처음에 계산하고, 그를 랭킹하고 상위 몇개의 튜플을 선택하는 것이지만, 이는 극단적으로 비싸다.
네트워크를 이동한다고 생각했을 때, 풀 조인 을 하지않고 결과 셋을 만드는 것이 중요하다. 

### 공헌
NoSQL에서 top-k 조인쿼리를 효율적으로 하는 법은 몹시 부족하다. 
우리는 Hive나 pig를 기본 베이스라인 기술로 상정하고, 병렬방법으로 쿼리를 실행할 것이다.
그러나, 그들의 단점을 인정하여 우리는다양한 다른 접근을 연구한다. 

첫째로, 맵리듀스 솔루션을 공헌한다.
둘째로, no-맵리듀스에서, Inverse Score List Rank Join이라는 알고리즘을 만들었다. 
셋째로, Bloom Filter Histogram Matrix라는 랭크 조인 통계접근 구조를 만들었다.

우리는 이 세번째 알고리즘이 100% recall을 달성했다는 걸 증명한다. 

더 나아가, 우리는 업데이트 상황에서 색인을 효율적으로 유지하는 알고리즘을 제안한다. 

측정영역은: 쿼리 프로세싱 시간, 네트워크 대역폭, 쿼리 프로세싱 비용

## 관련 연구
1. 랭크 쿼리
   - 잘 알려져 있는 랭킹 연산자는 top-k, kNN이다. 
   - top-k 연산자는 전형적으로 레코드 세트를 수용한다. 하나의 집계 함수, 그리고 k, ID를 만들어낸다.
   - kNN은 좀 다르다. 테이블을 레코드로 받고, 유사성 개념을 만들어낸다. 
   - 이 논문은 top-k에 집중한다. 
2. 랭크와 조인 쿼리
   - kNN 조인은 랭크와 조인 연산자를 모두 가지고 있다. 
   - 점수 속성을 집계하여 나온 결과를 연산하므로 top-k와는 다르다. 
3. 클라우드에서의 조인 쿼리
   - 최근 클라우드 조인쿼리는 각광을 받고있고, 맵리듀스를 이용하여 Hive, Pig가 조인을 지원한다.
   - 하둡은 NoSQL 시스템과는 다르게, 병렬적인 DBMS다.
   - 트로이목마 색인을 도입, 데이터 로드 타임에 만들어지고 각각의 매퍼에 의해 배치된다.
   - 이 매퍼들은 값비싼 디스크 스캔을 피하고, 릴레이션을 나눈다. 
4. 블룸 필터, 조인, top-k
   - bloom 필터는 비트로 데이터를 표현하는 자료구조다. 
5. 분산 환경에서의 랭크 조인
   - 1-4는 topk 등가 조인 쿼리를 해결하지 못했다.
   

## 베이스라인 랭크 조인
두 가지의 등가 조인에 집중한다: 알고리즘을 다양한 조인으로 확장하는 것
처음으로는 Hive, Pig의 접근을 표현한다. 

### Hive, Pig의 랭크 조인
하이브에서는, 랭크조인이 두개의 맵리듀스 job과 마지막 스테이지로 이루어져있다. 
- 처음에는 일단 조인 결과를 계산, 구체화한다. 
- 두번째는 조인 결과 점수를 계산하고 그들의 점수 기반으로 정렬해서 저장한다. 
- 세번째는 그를 기반으로 k 개의 결과를 낸다.

피그는 조금 더 현명하다. 그는 프로젝션을 실시해 처음에 top-k를 찾고 조정한다. 
- 조인 결과 계산: 매퍼가 테이블 스캔, 이른 프로젝션, 키와 같은 값과 행 emit, 리듀서가 한데 모아서 조인 결과를 만들고 하둡에 저장한다. 
- 두번째는 ORDERBY 결과물이다. 조인 결과를 맵 페이즈에서 샘플링한다. 그리고 적절한 분위수를 만든다.
- 이를 통해 파티셔너를 구성하고, 임시 점수 기록, top-k생성
  - 맵할 때는 임시 레코드를 만들고, 리듀스할 때는 각각의 top-k리스트를 만든다. 이 리스트는 할당된다. 마지막 top-k 결과 셋에.

## 인덱싱된 랭크 조인

BigTable/HBase는 전형적인 키-값 클라우드 저장소여서, 그들의 용어를 알고리즘과 예제에 사용하고자한다. 
그러나 그는 명확해서 우리의 색인과 알고리즘이 모든 현재 키밸류 스토어에 적용되어야한다. 

### Inverse Join List MapReduce Rank-join
맵리듀스를 사용하지만, 요구되는 맵리듀스 잡을 한번만 하기위해 인덱스를 사용한다. 
1. Index
위의 베이스라인 조인 방법에서, 첫 단계 매퍼는 사실상 인풋 튜플 리스트를 만드는 것이었다.
사실, 항목에는 조인 값이 키로 있고 입력 행은 특정 조인 값을 값 집합으로 지정하는 구체화된 뷰다.

우리는 공간 최적화 폼을 사용한다. 인덱스 값은 행 키와 스코어 값의 곱이다. 
이 인덱스는 큰 테이블에서 각각의 열로서 저장된다.

2. 쿼리 프로세싱
- 하나의 맵리듀스 잡으로 이루어져있다. 여러개의 매퍼와 하나의 리듀서가 그것이다. 이 잡에서는, 각각의 매퍼는 인덱스를 파티셔을 통해 스캔한다. 
- 각각의 행에서, Cartesian 곱을하고 조인 점수를 계산한다. 
- 매퍼는 인메모리 top-k 랭킹 결과 튜플만을 저장한다. 
- 리듀서는 각각의 top-k 리스트를 결합하고 전역 top-k결과를 내보낸다. 
- 이는 데이터 이동을 최소화했다. 하둡 프레임워크는 각각의 매퍼가 각자 데이커를 모으며 noSQL 스토어 위에서 실행되게끔 한다. 그러므로 top-k 결과는 네트워크에 옮겨져서 리듀서에서 정렬된다. 
- 이는 하이브에 비하여 쿼리 프로세싱 시간을 훨씬 줄였고, 몇몇에서는 대역폭도 줄었다.
- 그러나, 매퍼는 여전히 전체 인품 데이터셋을 스캔해야한다. 그리고 이는 비싸다. 

