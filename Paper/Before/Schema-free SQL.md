# 12/23 

SQL은 사용자가 데이터베이스의 정확한 스키마를 아는 것을 요구하기 때문에, 관계형 데이터베이스에서 쿼리를 날리는 것은 종종 어렵다. 
반면에, 키워드 검색은 원하는 쿼리 문법을 표현하긴 어렵다.

이 논문에서는 사용자가 부분적으로 스키마를 알지라도 쿼리할 수 있게 스키마 없는 SQL을 제안한다. 
스키마 없는 SQL은 어떤 릴레이션이 포함되었고 조인되었는지와 관련하여 정보를 요구하지 않는다. 

이를 평가하기위해 Full SQL로 스키마 없는 SQL를 변환한다. 
실험적으로는 적은 스키마 정보일 때, 정확하다는 걸 발견했다. 

## Introduction
정규화는 완벽한 스키마의 이해를 요구한다. 
그러나 쿼리가 예상가능하지 않을 때, SQL은 임시변통으로 사용할 쿼리를 지원하지는 않는다.

이 문제를 해결하기위해, 키워드 검색이라는 개념이 있었다. 
사용자는 쿼리 언어나 데이터베이스의 논리적 구조를 몰라도된다. 
몇의 키워드만 타이핑하면 되는데, 이는 본질적으로 모호한 부분이 있다. 
적절히 구조 정보가 명확화된 것이 아니면, 완벽한 쿼리 결과를 볼 수 없다. 그리고, 비교나 계산같은 SQL이 제공하는 함수가 보통 없다.

우리는 정확한 스키마 정보의 부담 없이 쿼리를 확실히 하고, 동시에 키워드 검색 결과를 하지 않도록 하는 수단을 제공하고자 한다. 

키워드 서치는 메타데이터의 키워가 아니라, 데이터베이스의 키워드를 찾게한다. 
이는 정확히 키워드를 적어야만 하는 문제가 있다.
게다가, 키워드는 집계 함수같은 것을 사용하지 못한다. 

따라서, 키워드 또한 구조화를 해야한다.

스키마 없는 SQL은 SQL쿼리를 작성하는 데 있어 사용자의 부담을 줄여준다. 
1. 스키마 경감: 사용자는 스키마 요소를 정확히 특정하지 않아도 된다.
2. Join 경로 경감 : 조인 경로를 특정하지 않아도 된다.

어느 정도까지는 유저가 요소 이름이나 조인 경로를 예측할 수 있다면, 사용자는 그를 포함할 수 있어야한다.

일단 사용자가 쿼리를 쓰면, 쿼리 프리 SQL은 그를 기반으로 관계 트리를 만들어본다.
또한 조인 경로를 만드는 과정에서, 스키마 그래프를 변형한 뷰 그래프를 만든다. 

이 연구가 공헌하는 바는 다음과 같다.
1. 스키마 없는 SQL 프레임워크
2. 시스템 아키텍처
3. 릴레이션 트리 
4. 뷰 그래프

## Overview
### 구문 및 의미
1. 스키마 경감: 물음표로 그들이 확실하지 않음을 드러낸다.
   - SELECT문에서 속성이 명확하지 않을 때, foo?를 적는다
   - ?x는 그 이름에 확신이 없을 때 적는다
   - ?라고 하면 그냥 더미 변수를 적어준다.
    스키마 요소를 말할 필요도 없다. 

2. 조인 경로 경감: 
   - FROM 구문을 쓸 필요도 없고, 
   - 외래키-프라이머리 키를 안써도 된다. 
   
### 아키텍처
두 가지를 경감한 뒤에, 전형적인 SQL 쿼리문으로 번역해서 쿼리 결과를 내보낸다. 

Relation Tree MApper는 스키마 경감을 위해 사용되고, NetworkBuilder는 조인 경로 경감을 돕는다. 
이 두 메인 모듈은 스키마 프리 SQL파서에 의해 진행되고 SQL composer에 의해서 계승된다.

1. 스키마 프리 SQL 파서
   유저들이 특정하는 조인 경로나 요소들은 불명확하고 파편화되어있다. 스키마 프리 SQL 파서는 스키마 요소들과 조인 경로를 나머지 쿼리와 분리한다.
   - Relation Trees라는 이름으로 요소는 표현될 것이고, views라는 이름으로 조인 경로는 대표될 것이다.

2. Relation Tree 매퍼
    - 릴레이션 트리와 데이터베이스의 릴레이션 사이의 유사성을 평가하고, 그 유사성에 의해 매핑한다.

3. 네트워크 빌더
    - Full SQL쿼리를 잡아내려면, 정확한 조인 네트워크를 형성해야한다. 
    - 네트워크 빌더는 뷰 그래프를 통해 네트워크를 만들어내는데, 
    - 이는 더 정확해보인다

4. Standard SQL 구성체
    - 정확한 스키마 요소를 만들어낸다. 
    - 각각의 구문을 채워가며, 완벽히 구성된 SQL 쿼리를 만든다. 

5. 중첩 쿼리
    - 위 1-4는 하나의 쿼리만 이야기하는데, 중첩 쿼리가 주어졌으 ㄹ때, 가장 밖의 쿼리부터 하나하나 진행한다.

## 스키마 프리 내용 소개
우리는 요소 이름이나 구조를 추측한다. 요소값을 받으면 어떤 속성인지 추측할 수 있는 힌트를 받는다. 
릴레이션 트리를 만드는 과정에서, 우리는 릴레이션 이름, 속성명, 값 조건을 구성하는 스키마 연관 내용을 명시한다.

### 세개의 표현식
- 릴레이션명 (From 구문)
- 속성명
- WHERE 구문에서 사용되는 구체적인 이름

이 외에는 스키마와 연관되어있지 않다고 생각된다.
만약 표현식이 세개의 표현을 특정하지 않으면, 우리는 별표시를 해놓는다. 

### 릴레이션 트리
저 세개의 표현식은 서로 독립적이지는 않다. 
1) 분명한 릴레이션명은 릴레이션 레벨에서 머지된다
2) 릴레이션명과 속성명은 속성 레벨에서 머지된다
3) 속성명은 명확한데 릴레이션 명이 없다면 속성레벨에서 머지된다.

이 머지된 결과를 릴레이션 트리라고 한다. 유사하게 속성레벨에서의 부트리는 속성트리라고 한다.
전처리 후, 모든 스키마 연관 정보는 릴레이션 트리의 셑으로 변환된다. 우리는 이것을 l-릴레이션 트리쿼리라고 한다. 

- l-키워드 검색보다는 l-릴레이션 트리가 더 많은 정보를 가지고 있다. 
- l-키워드 검색에서는 모든 키워드를 가지고 있는 조인 네트워크나 릴레이션들은 평가된 뒤에 랭크된다. 반면 l-릴레이션 트리는 평가 전에 랭크된다.

## 릴레이션 트리 매핑
1) 유사성 평가
![img.png](../img/img.png)
   n(rt)는 릴레이션 명이 n인 릴레이션 트리, R은 데이터베이스 릴레이션, at은 속성트리
2) 루트레벨 유사성

   - 릴레이션 트리의 뿌리에 릴레이션명이 있다면, 이 이름은 주된 힌트가 될 것이다. 
   - 사용자는 자주 이 릴레이션 명을 빼먹는다.
   - 이를 허용하기 위하여, 우리는 이웃 릴레이션 이름과 루트 릴레이션 이름을 매치한다.
   - 어떤 경우에는 n(rt)가 특정되지 않는다. 이 경우, 속성테이블에서 힌트를 얻는다. 
3) 속성레벨 유사성
![img.png](../img/2.png)

직관적으로, 속성 트리 at과 A는 속성명이 비슷할 경우, 속성 트리 조건이 튜플들에의해 만족된다. 

## View Graph
동일한 SQL query를 특정함에 기반하는 릴레이션을 포함하는 조인 네트워크를 찾아내는 것이 다음 단계다.
스키마 기반 키워드 서치에는 비슷한 문제가 있다. 

유저는 조인 경로의 부분을 특정할수도 있고, 키워드 서치에서, 길이 제한이 있는 모든 ㅈ조인 네트워크를 결과로 내보낼 것이다. 

따라서 View Graph라는, 부분적으로 특정된 조인 경로를 뷰로 보여주는 뷰 그래프를 소개한다.

### 모델
{view1, ..., viewm}가 있다고 가정해보자. 각각의 엣지가 조인인 연결된 트리다. 

이 뷰는 이용자에 의해 일부 특정되었을 수도 있고, 쿼리 패턴은 그럴듯한 쿼리일수도 있다. 

직관적으로, 조인 네트워크는 조금 더 그럴듯하다. 

각각의 릴레이션 트리에 매핑이 주어졌을 때, 그들과 연결된 많은 가능한 조인 네트워크들이 있다. 
이 문제를 해결하기위해, **확장된 뷰 그래프**라는 개념이 있다.

서로 연결된 릴레이션 트리도 있고, 아닌 경우도 있다. 모든 가능한 매핑을 고려해야한다.

### 결과 랭킹
l-relational tree query와 확장된 뷰 그래프가 주어졌을 때, MTJN은 하나가 아니다. 
많은 MTJN중 하나만 사실이다. 
어떤 MTJN가 좋은지 판단하기 위하여 우리는 그것에 점수를 매겨야한다. 
비중을 0에서 1까지 평가하여 점수를 매긴다.

여러개의 조인 네트워크가 있을 때, 해당 조인의 비중은 가능한 것들 중 가장 큰 것으로 한다.
엣지들의 비중은 특정 상수를 정하여서 1- (1-상수)* (1- 엣지가 비슷한 정도)로 한다.


## 스키마 프리 SQL의 가장 Top K위를 뽑다.

이러한 비중 함수는 휴리스틱하다. 그래서, 상위 몇위의 선택을 만들고자 한다.

### MTJN 상위 설정
초기 조인으로서 몇몇 노드 세트를 구하고, 점진적으로 확장해나간다. 
동일한 MTJN을 피하기위해, 일단 확장되면 각각의 root를 제거한다.

얼마나 JN이 확장되었는지에 따라 이 알고리즘의 효율성이 결정된다.

우리는 희망없는 JN의 싹을 미리 잘라낸다. 

중요한 두가지 함수가 잇다.
- Legality Test: 
  - 서로 다른 순서로 계속 엣지를 추가하다보면, 똑같은 루트에 같은 JN이 추가될 수 있다.
  - 그를 피하기위해, 유일한 숫자 라벨이 각각의 노드에 붙어서, JN은 각 숫자 라벨 노드를 자식으로 가지게끔 모델링된다.
  - 확장된 뷰 그래프에서는 조금 더 복잡하다. JN과 view가 정의되었을 때, view는 하나의 노드만 정확히 공유할 때 추가될 수 있다. 
  - 이 경우 루트의 맨 오른쪽 자식은 뷰에 있어야한다. 

- Potential 예측
  - JN이 주어졌을 때, 모든 MTJNs의 비중을 예측한다. 
  - 대략적인 상한이 현재 상위 k MTJN 비중보다 낮으면 포텐셜을 0으로 설정한다. 
  - 뷰 그래프에서 서로 가장 짧은 경로를 계산하는 게 이 예측의 복잡한 부분이다. 
  
### SQL Composer 기준
k MTJN가 만들어지면, k full SQL가 만들어진다. 
1. 모든 알려지지않았던 릴레이션명은 MTJN의 릴레이션명으로 대체된다.
2. MTJN의 모든 릴레이션은 FROM 절에 포함된다. 
3. 모든 MTJN의 엣지들은 WHERE절에 포함된다.


## 실험 결과
두 가지 기준: 효과성, 유저 사용성, 시간

- 효과:  Schema-free SQL queries의 부분을 카운팅하여 효과성을 평가한다. 
- 유저 사용성: information unit을 기준으로 한다. 쿼리에서 릴레이션명과 속성명을 포함하는 스키마 요소가 그것이다. 

### 영화 데이터베이스
- 유저 사용성이 다른 것들보다 좋았고, 정확도도 좋았다. 

### 코스 데이터베이스
- 번역을 하는 품질은 쿼리가 복잡해질수록 내려갔다. 
- 뷰 그래프를 사용하니 품질이 더 올라갔다 

# 결론
복잡한 쿼리를 구성하게 해주는 스키마 프리 SQL를 만들었다.
이를 뒷받침하기위하여, 우리는 모듈 아키텍처를 만들고 그 각각에 특정 기술을 붙였다: 부분 스키마 정보라던지, 유사성 기반으로 릴레이션 트리를 매핑하기, 뷰 그래프 위에 조인 네트워크를 구성하기, SQL로 번역하기 등이다.
이는 유저의 동작도 줄여주고, 효과적이다.