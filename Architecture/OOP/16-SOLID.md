소프트웨어설계를 이해, 유연, 설계가 쉽게 만드는
근데 원칙도 규칙도 아닌 방향성 제시, 알아두면 좋은 정도의 주관적인 내용
- 이미 기존에 존재하던 베스트 프랙티스를 이름만 바꾼 것도 있다. 
- 극단적 주장을 한 것도 있다. 

모든 코드를 SOLID에 맞추면 그 자체로 유지보수가 힘든 코드가 될 것이다. 

SOLID로 이룰 수 있는 것: 유연하다. 
추상적인 설계로 커플링을 제거할 수 있다. 
따라서 
- 대규모 프로젝트일수록 유용
- 그러니 모든 플젝에 적용은 어렵다. 

예전에는 외주로 개발을 많이 해서, 처음부터 스펙을 잘 준비하고 그 후 변경이 별로 없었다. 
그러나 요즘은, 스펙에 많은 시간을 퍼붓지 않는다. 그래서 재사용성 높은 설계가 좀 힘들다. 

## 단일 책임 원칙
- 클래스의 존재 이유는 하나여야만 한다.
근데 하나라는 의미가 정확히 무엇을 의미 ? 

즉 하나의 개념이 몹시 주관적이다. 

이는 이 코드를 보는 대부분의 사람이 이해할 수 있는 크기로 클래스를 만들자.라는 주관적인 의의

- 클래스를 바꾼다면 이유는 하나여야만한다.
  - 그 이유가 뭐가 될지 알 수가 없다. 
  - 그걸 몰랐으니까 나중에 변경할 일이 생긴 것이다. 
  - 그래도, 각 클래스의 책임을 분명히 정의하자는 의미로 대충 받아들이면 된다. 

## 개방-폐쇄
확장은 가능하게 수정은 불가하게. 
- 클래스 내부 수정 없이 동작을 확장할 수 있어야한다. 
- 상속이 좋은 예
- 이 정신을 잘 따르면, 단일 책임 정신도 더불어 이룰 가능성이 높다. 

## 리스코프 치환
1. 부모 클래스 개체를 사용하는 코드 A가 있다.
2. 나중에 자식 클래스 개체를 거기에 대신 사용함
3. 이때 A가 아무 문제없이 작동해야한다. 

즉 부모가 할 수 있던 일은 자식도 할 수 있어야한다. 
```java
public final class Stack<E> extends ArrayList<E> {
  @Override
  public void add(int index, E element){
    super.add(element);
  }
  @Override
  public E remove(int index){
    assert this.size() > 0;
    int lastIndex = size() - 1;
    E element = get(lastIndex);
    super.remove(lastIndex);
  }
  @Override
  public boolean remove(Object o){
    if(this.size() == 0){
      return false;
    }
    remove(0);
    return true;
  }
}
```
위의 코드처럼 작성하게 된다면, ArrayList가 선입선출할 수 있게끔 코드가 짜여져도 Stack은 할 수 없다. 따라서 특징에 맞지않는 걸 상속하면 안된다.
## 인터페이스 분리 정신
큰 인터페이스가 몇개 있는 것보단, 작은 인터페이스가 많이 있는 게 좋다. 
메서드를 한 인터페이스에 넣는 대신, 
여러 메서드 인터페이스로 분리하자는 이야기!

무조건 그래야하는 것은 아니다. 한 메서드당 한 인터페이스라면 모든 걸 함수 포인터로 만드는 게 맞다. 

## 의존 역전 방식
추상적인 것에 의존하고 개체끼리 구체적인 것끼리 통신하지 말 것. 그러나, 구체적인 것에 의존하는 것이 필요하다는 점은 이제까지 계속 배워온 사실이다.

## 결론
소프트웨어 품질의 시작은 개발자의 실수 줄이는 시스템 구축. 모두가 이해하기 쉬운 코드를 작성할 것! 

언제부터 디커플링을 고려해야 할까? 
- 협업환경에서 잦은 변경으로 서로 일 못하는 상황이 생길 때
- Solid는 그때 사용 검토

필요하면 사용할 것. 필요없는 걸 굳이 하려는 사람은 민폐다.

