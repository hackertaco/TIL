인터페이스를 사용해야하나, 클래스를 구현해야하나? 논의
### 의존성
- SW module A가 작동하려면 module B가 필요한 경우 
  - OO에서는 모듈이 곧 클래스
  - B가 없으면 A가 안된다는 뜻.
- 엄밀하게 이야기해서는, 의존성이 있어야 좋은 설계다. 
  - 각 클래스의 목적이 뚜렷하다는 의미
  - 캡슐화가 잘 되어있다는 의미
  - 클래스를 재사용할 수 있다는 의미다. 

### 의존성과 결합도는 다르다. 그러나 OO에서는 같게 사용한다. 

### 결합도란? 
- 2 module 사이의 상호 의존성 정도다.
- 클래스 A가 B에 의존
- B도 A에 의존

## OO에서 논하는 결합도란
꼬리물기가 아니라, A가 B에 의존하는 상황에서 B를 변경할 때 프로그램이 잘 작동하는가? 다.

1. A의 내부를 변경 안 해도 제대로 동작: 결합도가 느슨하다고 말한다. 
2. A의 내부를 변경해야만 제대로 동작: 결합도가 높다.

개체지향 설계 쪽에서는 결합도를 B 코드 변경 시 A 코드도 변경해야하면 결합도가 높은 것으로 파악한다. 

의존성은 모든 모듈에 있는 것인데, 심하게 의존하는 것은 결합도가 높은 것으로 파악된다.(개체지향 내에서)

## 결합도 판정
결합도는 의존하는 코드가 바뀔 때 코드를 바꾸어야할 때 높다. 

어떻게 결합도를 줄일 것인가? 
- 매개변수로 전달하는 방식으로 (자료 결합도)

## 의존성 주입
의존하는 모듈을 직접 넣어줬다라는 의미가 의존성 주입이다. 
- DI의 경우 다른 것을 의미하기도 하니 주의해야한다. 
  - 의존성 주입 컨테이너나 의존성 역전도 있다.
  - 의존성 주입과 의존성 역전 헷갈릴수도 있다! 
- 생성자 주입과 setter 주입 등이 있는데
  - setter 주입은 개체의 유효한 상태에 해가 될 수도 있다. 개체는 생성시부터 유효해야하기 때문이다. 
- DI로 얻은 것
  - 결합도를 낮춤
  - 나중에 생성자가 바뀌어도 의존하는 모듈을 바꿀 필요가 없다. 
- 잃은 것
  - 편의성 
  - 프로그래머의 원 의도를 왜곡할수도 있다. 

## 디커플링이 적합한 곳들
인기 많은 클래스가 있는 상태에서, 해당 클래스를 바꿀 때, 커플링은 참 문제다. 의존되는 클래스 내부를 다 바꾸어야할 수도 있기 때문이다.

### 디커플링의 단점
디커플링은 유연성, 재사용성을 높인다. 그런데 이는 미래의 변화에 대비되어 있다는 의미다. 

하다보면 근데 효율적이지 않고 단점들이 보인다.
- 직관적이지 못하다.
  - 이를 해결하기위해 제일 위의 호출자를 찾을 수 있다. 그런데, 실행 파일 하나에 구현이 하나인데 인터페이스에 접근을 하고 있는 상황일 때! 
  - 한 프로그램에서만 검색해보면.. 그러나 소스코드에 안 보일수도 있다 (DI Container)
  - 실행 중에 확인한다. 디버거를 통해! 그런데 실행하는 데 프로그램을 2시간 실행해야한다면 ????
- 내부를 알아야 좋은 경우도 있다. 
  - 애매해지는 부분도 있다. 중복을 허용하지않는 메서드가 있다 할 때, 내부가 어떻게 되어있는지에 따라 알고리듬이 달라질텐데, 모든 경우에 다 작동하게 하려면 가장 느리고 일반적인 방법을 선택해서 오히려 비효율적일수있다. 

## 모든 것은 인터페이스여야한다는 주장
위의 단점들이 분명히 있는데도 불구하고, 모든 것을 인터페이스로 만들라는 사람들이 있다. 
모든 것에 대비를 할 필요가 없다. 
인터페이스: 구현 = 1:1은 이상한 일이다. 

- 다형성이 필요 없는데, 클래스마다 인터페이스를 만드는 꼴이다. 
  - 그 이유는, 인터페이스를 잘 이해하지 못하였기 때문이다. 
- OO의 인터페이스: 상태도 메서드 구현도 없는 순수 추상 클래스
  - public 메서드 시그내처만 모아둔 것. 
  - 함수 포인터처럼 사용할 수 있는 것
  - 다중 상속을 흉내내는 방법
  - 변화에 대비해 결합도를 낮추는 것 (단, 다형성이 필요할 때)
  - 다형성 없는 인터페이스는 없다라는 주장이 OO에서는 일반적이다. 
- 인터페이스가 다양하게 받아들여지는 이유? 
  - 프로그래밍 언어마다 인터페이스라는 용어 및 키워드를 다르게 사용하기 때문에
  - 개체가 이해하는 명령을 나열한 것이라는 개념적 정의도 있다. 
  - 그러나 다형성을 뺀 채 해당 개념만 받아들이면 조금 이상해진다. 
    - 왜 인터페이스만 중시하는지? 
    - 디자인 패턴을 너무 성스럽게 곡해함! 

## 인터페이스에 대해 프로그래밍하라는 의미
위의 클래스를 사용할수록 결합도가 낮아진다는 의미.
- 함수는 블랙박스다라는 말에 다형성을 추가하는 것이다. 클래스 의미로 확장한 것이다. 
- 뭐든 간에 다형성을 가진 일반적 메서드 시그내처를 정의하는 것이 핵심이고, 
- 자바 언어의 인터페이스를 말하는 것이 아니다 !

## 인터페이스의 올바른 정의 
협업시 가장 중요한 목표는 실수를 예방하는 것이다. 
- 모두가 직관적으로 이해할 수 있는 방법으로 실수를 줄여야한다. 
- 필요도 없는데 인터페이스 등으로 직관성을 줄이지 말자! 기본적으로 추상화를 안 하는 게 실수가 적다. 

## 이클립스 API와 인터페이스
디커플링 정말 잘한 예? 
- 이클립스 API로 기본 이클립스를 보완하기도 한다. 
- 그런데 api 버전이 올라가도 변화는 적어야한다. 메서드 시그내처가 매번 바뀌면 안되지! 
  - 그래서 변화를 최대한 줄이는 방법이 필요하다. 
  - 그렇지만 바뀌는 것도 있어야한다.
    - interface: 절대로 안 바뀌는 것
    - class: 언제든 바뀔 수 있음
    - 이라는 의미를 부여하였다. 
    - 그러나 결국 인터페이스도 발전시켜야했다. 그러나 그러면 약속을 어긴 셈. 
    - 그래서 인터페이스 이름에 숫자를 붙이기 시작했다. ..! 
    - 이 방법은 약속은 지킨다. 그러나 깔끔하지는 않다. 더불어 인터페이스와 클래스를 확실히 구분하는 프로젝트는 많지않다.

## 실용적인 인터페이스 사용법
- 기본적으로 클래스
- 다형성있는 다중 상속이 필요한 경우나 함수 포인터의 경우 인터페이스 사용
- 