다형성: 다양한 형태로 변할 수 있는 능력
- 같은 지시를 내렸는데, 다른 종류의 개체가 동작을 달리하는 것
- 어떤 함수 구현이 실행될지는 실행 중에 결정됨.
- 일반적인 함수 호출은 이른 바인딩
    - 늦은 바인딩이라 한다.
  
- 자식 개체에서 부모에게 받은 함수를 다르게 구현. 

함수를 오버라이딩해버리면 부모의 함수는 호출이되지 않는다.
- 부모 개체를 만들어도 동일한 규칙이 적용된다. 
- Animal animal = new Dog(); 
  - 이 경우 Dog 안의 메서드 호출

다형성은 구체적으로, 어떤 개체가 다양한 형태로 변할 수 있는 능력! 
- 어떤 개체란 부모 클래스형의 변수로 참조 중인 개체
- 다양한 형태란 실제 개체에 구현된 메서드

## 코드로 본 다형성의 의미
1. 겉보기에는 같은 형: 부모가 자식 개체 참조
2. 개체들에 내리는 동일한 명령: 부모 클래스에서 메서드의 시그내처를 정해주어야한다. 오버라이딩!

### 오버라이딩은 선택사항이다.
부모의 동작도 유지하면서 오버라이딩도 가능하다.
만약 부모의 메서드 호출하고 싶다면 super.shout()같이 하면된다

## 다형성의 장점
자식 실체에 따라 결과가 달라진다.
- 각 자료형의 코드가 클래스 안에 들어가니 캡슐화 up
- 유지 보수성도 높아짐
- 새로운 클래스 추가시, 클래스 코드만 추가하면 된다. if문 줄어들어.
- 클라이언트가 작성할 코드가 줄어든다.

### 늦은 바인딩과 이른 바인딩
다형성: 늦은 바인딩. 실제로 호출되는 메서드 구현이 프로그램 실행 중에 결정된다는 의미. 동적 바인딩이라고도 한다.
- 어떤 함수 구현을 호출해야할지가 빌드 중에 결정나는 것은 정적 바인딩. C에서 배운 함수의 호출 방식 -> 다형성을 지원하지 않기 때문에 가능

### C 함수 포인터와의 비교
- 대표 예 : 퀵솔트 함수의 마지막 매개변수
- C에서의 다형성이라고도 할 수 있다. 

- 가상메서드? 자식 클래스에서 동작을 오버라이딩할 수 있는 메서드


## 이른 바인딩과 늦은 바인딩의 성능
- 둘 중에 cpu 최적화가 더 잘 될 가능성이 높은 것은 이른 바인딩
  - 빌드를 해서 컴파일 중에 충분한 시간을 들여 최적화를 할 수 있다.

### 오버라이딩 막기
- 자식의 오버라이딩을 막는 방법도 있다.
- 메서드에다가 final을 추가! 자바에서 이른 바인딩으로 사용되는 방법이기도 하다.
> public final int getHeight(){}

클래스에서 final을 붙이기도 한다.
- 이는 더이상 상속하지 못한다는 뜻이다. 
- 자식 클래스가 존재 불가.

이런 final을 기본적으로는 붙이는 게 좋다.
- 외부에 제공하는 라이브러리나, 상속 및 변경할 클래스나 메서드를 제외하고는 ! 

## Object 클래스와 toString()
일반화의 끝판왕 Object에 있는 메서드
- 원한다면 object 오버라이딩 가능! 
- Java의 클래스는 모두 Object로부터 상속을 받기 때문이다.

## equals() 메서드
문자열 동치 비교할 때 쓰는 메서드
> public boolean equals(Object obj)

- 기본적으로는 단순한 주소를 비교하는 것이다 this == obj
- 내부를 일일이 비교하지는 않는다. 
- 근데 클래스마다 같다는 의미가 다를 수있다. 그래서, 데이터를 비교해야한다면 오버라이딩이 필요하다. 
- 이 경우 hashCode도 같이 오버라이딩해야한다. 
- obj도 비교하고 + 널인 경우도 비교해야! 

## hashCode() 메서드
- 어떤 개체를 대표하는 해시값을 32비트 정수로 반환
  - 동치인 두 개체는 해시값이 같다. 
  - 그러나 동치가 아닌 두 개체도 해시값이 같을 수 있다. 
- 주 목적: 자바가 자체 제공하는 hashmap class에서 사용하기 위하여
  - 덕분에 빠른 비교용으로 사용 가능하다. 두 개체가 같지않음만 빠르게 판단 가능.
  - 동치 개념 바꿀 때 같이 바꾸어야한다.
  - 