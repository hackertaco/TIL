## 다형성, 상속, 추상화의 관계
상속과 다형성은 추상화에 기반된다. 
추상화란, 여러 클래스에서 공통 분모를 뽑아 부모 클래스를 만들거나, 오버라이딩하는 것들

- 그러나 새로운 개념은 새로운 문제도 가져온다.

## 다형적인 Monster class 구현
- 몬스터 종류는 오우거/유령/트롤
- 타입별로 피해주는 정도를 다르게할 수있다. 
- 몬스터 종류 추가도 가능하다.

## 자식클래스에서의 문제
- 근데, 부모의 메서드를 너무 넓게 잡으면 다형성 범위가 너무 넓어진다. 
  - inflictDamage method를 실제로 자식 클래스에서 사용하지않을 경우가 있다.
  - 그러면 의도치않은 결과가 나올 수있다.

    - 그럼 그냥 구현이 없는 메서드로 바꿀 수 있다.
        - 시그내처는 있고 함수 속 코드는 없다.

- 또한, 어느 종류에도 속하지 않은 몬스터를 생성할 수 있는데 그게 말이 되는지?? 
  - 즉 몬스터는 추상적인 클래스.

## 두가지 실수
1. 몬스터의 자식 클래스가 다형성 함수를 구현 안 하는 것
   
2. 몬스터의 인스턴스를 만드는 것
을 막고싶다.
이를 해결하기 위해서
- 지우면 된다. 구현 부분을.
    - C 언어에서 보았듯이, 시그내처 만들어주면된다.
    - 근데 아래와 같으면 컴파일 오류가 나게된다
  > public int calculateDamage(Monster target);
    - abstract를 붙여야한다.
    - 근데 그러면 attack의 함수 내부에 calculateDamage를 호출하는 부분이 있는데, 이 때문에 말이 안된다는 컴파일 에러를 받게 된다.
    - 그래서 Monster 자체를 추상 클래스로 선언해야한다.
    - 그렇게 되면, 말을 안 듣는 자식이 원하는 다형성 메서드를 오버라이드 해야만 하게 된다.
    - 더불어, 몬스터 인스턴스도 만들 수 없다.

## 추상 클래스
<접근 제어자> abstract class <클래스명> {...}

- 인스턴스를 만들 수는 없다. 
- 다른 클래스의 부모 클래스가 될 수는 있다.
- 반드시 추상 메서드가 들어 있을 필요는 없다.
- 메서드 구현이 없을 수도 있다.
- 코드 중복을 막기위해 만든 클래스라면 추상 클래스로 바꿀수도 있다. ex. Teacher의 경우 전임강사와 시간강사로 나눈다면 굳이 teacher 클래스 인스턴스가 필요한 건 아니다.
- 