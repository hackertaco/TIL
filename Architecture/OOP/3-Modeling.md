
## OOP 설계
- 이렇다할 정답이 없다. 
- 한 방에 제대로 설계하기도 어렵다.
- 여러번 다시 고치기가 쉽다.

### 클래스 다이어그램
- 어떤 시스템에 있는 클래스들을 보여주는 다이어그램.
  - 클래스 안에 들어있는 상태, 동작, 접근 제어자
  - 클래스 간의 관계
- 시스템의 정적인 구조를 보여주기에 적합.
- UML의 일부
  - 시스템의 디자인을 시각화하기위해 만든 표준
  - 공통으로 그림을 그리는 방법을 만든 것.
  - 예전에는 정보도 별로 없고, 회사 자체가 외주사 컨설팅사가 많아서 통일된 형태가 필요했지만, 이제는 아니다.
- 멤버 변수, 접근 제어자, 메서드, 의존 관계 등을 표현한다.

## 모델링
### 분무기
- 클래스명 WaterSpray
  - 상태: 현재 남아있는 물의 양
    - int remainingWaterInML = 0
  - 생성자
  - 언제라도 남은 물의 양을 확인하는 getter 추가
  - 물이 떨어지면 채우는 setter도 추가 (기존에서 더하는지, 혹은 절대값까지 물을 set할지)
  - 
#### 분무기 동작
물뿌리기
  - 동작에 초점 맞출 경우
    - pull
    - press
  - 용도에 초점을 맞출 경우
    - spray (선택!)
      - 반환을 한다면 뭘 반환하는지 알기 힘들고
      - 메서드가 하는 일이 너무 많다고 볼 수도 있다.
      - 그래서 반환하지 않는 것이 더 좋다. 
      - 반환한다면, sprayAndGetUsedAmount..
  * 필요 없는 상태와 동작을 클래스에 넣을 생각은 하지 말 것.

#### 분무기 용량 추가
최대 용량이 필요하다
- 모든 분무기의 용량이 같은 경우
  - > private static final int CAPACITY = 200;
    - 클래스 다이어그램은 이를 포함하지않는다. 실제 구현은 보여주지않는다. 
    - 상수는 멤버 변수에 속하지 않는다. 
- 분무기마다 용량이 달라질 수 있는 경우
  - 생성자에서 초기화되고 변경이 불가능한 멤버 변수
  - capacity를 멤버 변수로 선언해준다.
  
가득 채워야겠다 동작 추가하기
- fillUp(){} 메서드 추가 
  - > this.remainingWaterInMl = capacity

#### 수도꼭지
뭐로 물을 채우나? 문제의식에서 출발
Faucet이라는 클래스를 만들면? 
- 이러면 결국 클래스 두개 모두가 addWater라는 함수를 가지고 있어야한다. 
- 패키지 접근 제어자로도 가능은 하다 (addWater를 중복시키지 않아도.)
- 근데 그 전에, **정말 Faucet 클래스가 필요한가?** 
  - 정말 토끼굴에 들어갈수도 있다!!!

### 화분
클래스명은 FlowerPot
상태로는 살았는지 죽었는지
- alive: boolean = true
- 생성자는 하는 일이 없다. 
- getter는 isAlive(): boolean
- 한번 죽은 꽃은 되살아나지 않기 때문에, setter가 없다.

생존에 필요한 물의 양을 기억할 변수가 있어야한다.
- minDailyWaterInMl: int
- 꽃마다 다른 양이 필요해서, 생성자를 통해 초기화한다. 
- getter는 getMinDailyWater:int

화분에 물을 줄 수 있어야한다.
- addWater? 
  - amountInMl < minDailyWaterInMl 이면 alive = false
- 그러나 이 경우, 한번 뿌리면 하루가 지났다고 판단하기 때문에 두번 뿌려도 괜찮게끔 해야한다. 

그래서, 
dailyWaterReceived 변수 추가
liveAnotherDay라는 하루를 보내는 함수를 추가한다. 

#### 문제는 WaterSpray와 Flowerpot 사이 상호작용이 없다. 
구조체 사고방식에서 벗어나지 못한다. 
그냥 데이터 저장소로 사용하게 되는 것이다.
누군가 이 두 클래스 사이에서 중재한다.

1. 분무기를 화분에 대고 뿌린다.
   - 새 메서드 sprayTo(FlowerPot)
   - spray() 메서드는 없어도 된다.
   - 이렇게 되면 waterspray.sprayTo(pot) 하면 된다. 

2. 분무기를 줄테니 알아서 뿌린다.
   - FlowerPot의 addWater를 변경
   - pot.addWater(waterSpray)
   
둘 중에는, 우리에게 익숙한 생각인 1이 좋다.

그런데, 개체지향적 생각은 2번이다.
- 실세계의 물체는 완전히 수동적이지만, 
- OO 세계의 물체는 어느정도 자기 주관을 가진 주체다.
  - 그래서 개체란 용어가 더 적합.
  - 주체성을 가진다고 생각하길
  
### 이는 유연성은 떨어진다!
화분에 물을 줄 때 컵을 사용하고 싶으면? 안된다.

재활용성은 없다. 

#### 분무기를 두 부품으로 분리해보면? 
SprayHead, SprayBottle 두 개로 분리
- SprayHead
  - sprayAmount
- SprayBottle
  - capacity
  - remainingWater
- WaterSpray는 머리와 몸통의 집합
  - composition으로 봤다면 분리하지 않았을 것.
  - 이 장점은 여러 종류의 머리와 몸통을 조합 가능
  - 근데 서로 SprayHead, SprayBottle 사이 메서드가 변경되어야한다.
    - 서로 의존성 추가
    
뭔가 불편하다.
머리랑 몸통을 따로 만들고, 물 뿌릴 때도 머리랑 몸통을 각각 호출해야한다.

- 유연성 높은 설계가 최고라고 이야기하기는 어렵다. 
- 함수의 경우에도, 재사용하면 좋지만 너무 쪼개지면 읽기가 힘들다.
- 코드 유연성은 양날의 검이다. 

그렇다면 어떻게 해야하는가.
나누되, 규격을 정할 것 ! 


