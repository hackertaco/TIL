## 상속
거의 모든 사람이 OOP의 핵심이라 여기는 특성이다. 
- 다형성의 기반이 된다.

### 상속과 재사용성이 무슨 관계? 
여기서의 상속은, 어떤 특징을 물려받는 것에 좀 더 가깝다.

### OOP에서의 상속이란? 
어떤 클래스를 기반으로 새 클래스를 만드는 방법
- 유전과, 진화 모두 포함한다.

### 상속 관계를 설명하는 표현
- 상속받았다. 
- 파생되었다.
- 자식클래스가 부모 클래스의 한 종류다. (is-a)

## 중복 코드를 클래스로 분리하기
- 선생과 학생이라는 각 클래스가 있을 때, 둘다 사람이기 때문에, 중복 코드가 많을 수밖에 없다.
- 그럼 그 공통분모인 Person class를 만들어볼 수 있을 것 같다.
- 이 person을 상속 받아서, 각 클래스만이 가지고 있는 특질을 추가해서 클래스를 만든다. 

## 상속하기
```
public class Student extends Person {

    private Major major;
    public Student(){
        
    }
}
```
- 부모 부분의 초기화는 부모의 생성자가 담당한다.
- 자식 부분의 초기화는 자식의 생성자가 담당한다. 
- 근데 자식 개체를 만들 때 부모도 같이 초기화해주어야하는데, 그럼 누구부터 초기화해야할까? 
- **부모부터** 초기화한다.

1. 메모리에 개체 생성
2. 부모 생성자 호출
3. 자식 생성자 호출

근데, 자식 생성자에 어떻게 부모 생성자를 호출할지 정해주지 않았다. 
> 그렇게되면 알아서 컴파일러가 부모의 매개변수가 없는 생성자를 호출!

그런데, 매개변수가 없는 생성자가 부모 클래스에 없다면?

개체는 생성 시부터 유효한 상태를 가져야하기 때문에, 매개변수 없는 생성자가 없다고 해서 그를 인위적으로 만들어서는 안된다.
- 그래서, 자식 생성자에서 부모 생성자를 호출, 매개변수가 있어야한다. 
- super(arg, arg2) 이렇게, 
- super는 현 개체의 부모 부분을 가리킨다. 마치 현 개체 내 변수를 가리킬 때 this.를 쓰듯이 super. ! 
    - 따라서 멤버변수나 메서드를 호출할 때도 사용이 가능하다. 

### 부모 개체의 독립성
여전히 Person 개체도 만들 수 있다.
단, 자식의 멤버에 접근할 수 없다. (메서드나 변수)

### 생성자 호출(super)는 생성자 호출 내에서 제일 위에 와야한다.

## 부모 멤버에 접근하기
- 이메일을 추가한다고 해볼 때,
  - 선생 클래스만 그를 수정이 가능하다는 가정 하에
  - protected로 이메일 접근 제어자를 바꾸면 된다. 
    - 외부자들은 접근 불가. 클래스 내부, 같은 패키지에 속한 클래스, 자식 클래스만 접근이 가능하다. 
    - 클래스의 경우 내포된 클래스에 한해 붙일 수 있다. 
    
  - 선생 클래스에서 super.email = email로 (super 대신 this도 가능) 멤버 메서드를 넣어 바꿀 수 있게끔 한다.
- 클래스 다이어그램에서 protected는 #이다.

## 상속의 상속
ex. 전임강사 -> 오피스 o, 시간 강사 -> 일주일에 몇시간 일하는지 정해짐.
- 이걸 클래스로 만든다면?

- person -> teacher -> full or part-time

## is-a, has-a 관계
- is-a
  - 상속 관계, 수학에서는 부분 집합 관계 A student is a (still) Person.
- has-a 
  - 컴포지션
- 상속과 컴포지션
  - 둘 다 재사용성을 위한 방법
  - 상속으로 해결할 수 있는 많은 문제를 컴포지션으로도 가능하다. 
  - 반대도 가능하다. 순전히 기술적인 관점
  - 초창기에는 상속을 과도하게 선호했다. 
- 이 상속과 컴포지션 중 하나를 고르는 것은 가장 큰 결정사항 중 하나다.

## 실제 프로그래밍에서 is-a 관계를 어떻게 활용할 것인가.
"학생은 사람이다" 라고 했다. 그렇다면
부모 개체에 자식 개체를 대입 가능한가? = yes , **이건 캐스팅이다!** 대신, 암시적으로 해준 것일 뿐이다. 

but, 자식 개체에 부모를 대입은 불가함.

## 상속과 명시적 캐스팅
- 근데 명시적 캐스팅을 하게되면 자식에 부모를 대입할 수 있다.
- > Student actually Student = (Student) person;
- 근데, 전혀 상관없는 클래스로 캐스팅할 수는 없다. 
- 컴파일러는 상속 구조를 알고있고, 구조 상 말이 안되는 경우 오류를 잡아준다.
- 그런데, 컴파일러가 못 잡아내는 경우도 있다. 아래의 경우는 실행 중에만 오류가 난다.
> Person person = new Student("Leon", "Kim");
> 
> Teacher teacher = (Teacher) person;

## instanceof 연산자
위와 같이 런타임 예외가 생길 경우? 

실제로는 이 person 개체가 실제로 teacher인지 확인하고, 실제로 teacher인 경우만 캐스팅 하고싶은 경우 -> RTTI
> instanceof 연산자를 사용!
> 
> person instanceof Student

- instanceof는 반드시 그 개체여야하는 게 아니라, 그 개체가 상속받은 개체면 다 가능하게끔 되어있다.
### instanceOf()와 비슷한 메서드 -> getClass()

.getClass().getName() 하면 클래스명을 반환한다.
- 클래스 이름을 찾을 때
- 클래스 안에 있는 메서드나 멤버 변수 등도 찾을 수 있다. 
- .getClass().getName()를 정말 많이 사용한다. 

그런데, RTTI는 좋아보이지만 그만큼 실행 중에 뭔갈 많이 한다. -> 성능 또는 메모리가 중요한 경우에는 별로다. 
그래서, C/C++ 등의 언어에서는 RTTI 지원이 없거나 사용하지 않는다. 

근데 getClass()는 어디서 왔을까? 내 클래스 안에 직접 구현 안했다면! 
- Object 클래스에서 상속 받은 것
- 자바의 모든 클래스는 Object라는 클래스를 상속받는다. 
- 이 안에 있는 메서드가 바로 getClass(). 근데 이거 말고도 많다.
- 