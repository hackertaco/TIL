## 왜 하필 클래스일까?
자연세계에서의 클래스: 생물학에서 강이라고 부른다. 
이 강은 종이나 과보다 상위 개념이다. 

어떤 개체든지 속한 클래스가 있다는 말이다.

## OOP에서의 클래스
명세서라고 생각하는 게 편하다.

## 간단한 클래스 코드
> public class Human{
>   public String name;
> 
>   public void 함수;
> }

### public
접근 제어자, 멤버 변수, 멤버 함수 모두 있다. 
외부에서 클래스 내부에 담긴 상태와 동작에 접근하는 것을 허용한다.

-> 외부는 다른 패키지를 의미한다.
- 이를 쓰지 않으면 컴파일 오류가 난다!

#### 번외: 상태를 칭하는 용어
멤버 변수, 필드, 속성 등..

#### 번외: 동작을 칭하는 용어
멤버 함수, 메서드, 메시지

### 인스턴스
개체를 부르는 또 다른 표현이다. 
어떤 클래스에 속하는 개체의 한 예라는 뜻이다. 
- 인스턴스화: 클래스로부터 개체 하나를 만드는 행위

개체는 
> Human adam = new Human()

이렇게 만들면, 어떻게 접근할까? 


### 포인터 vs 참조형
- 참조형의 자료형은 사실상 포인터다. 
- 메모리 주소를 저장하는 변수 = 포인터
- 힙에 위치한 Human 개체의 주소를 포함한다.

- 자바는 기본 자료형 제외하고는 포인터가 있다. 
- 포인터 연산이 불가능할 뿐이다.

#### C는 개체를 포인터 혹은 값으로 둘 다 전달이 가능하다. Java는 포인터로만 전달이 가능하다.

### 개체 생성시 멤버 데이터의 초기화
- Java는 0에 준하는 값으로 초기화해준다.
  - 참조형은 널로
- 실수 방지가 중요하기 때문이다.

### .연산자의 다른 의미.
기본적으로 개체의 멤버에 접근할 때 . 연산자를 사용한다. * 연산자 없다.

## 개체의 멤버 함수 호출하기
- 개체 속에 함수가 있으니 역시 .연산자 사용, 호

### 자바에는 free()가 없다. JVM의 가비지 컬렉터가 알아서 치워준다!
#### 자동에는 대가가 있다. 
- 가비지 컬렉터가 메모리를 수집하는 시점을 알 수가 없다. 
- 모든 개체의 사용 여부를 판단하는 게 그리 빠른 연산이 아니다.

따라서, 자원이 한정적인 시스템에는 적합하지않고, 
메모리 누수도 존재한다. (적기는 하다)

## 생성자(constructor)
- 개체 생성 시, 자동으로 호출되는 특수한 함수
- 반환형이 없다.
- 함수명은 클래스명과 동일하다!
> public <class 명>(<매개변수 목록>)
- 이는 오버로딩도 가능하다.
  - 코드 중복이 생길 수 있다. 
  - 코드 중복을 피하려면, this()안에 매개변수 넣어 호출.
    - 매개변수 수가 적은 쪽에서 많은 쪽을 호출
- 생성자가 있는데, 매개 변수를 넣지않으면 컴파일 오류
  - 생성자 없으면, 자동으로 만들어준다. (기본 생성자)

## 생성자로 초기화를 해야하는 이유?
- 처음부터 초기화하거나
- 생성 직후에 어떤 값을 바꿔주거나 -> 실수가 많아진다.
- 생성자는 개체를 만들어주는 계약이다. 최대한 많은 멤버 변수를 초기화해주는 것.
- 외부에서 내부의 데이터를 알 필요 없게 해준다. (데이터 추상화)

## 코드보기: 
- 제일 위에는 package 명 써주기. 안쓰면 컴파일에러

## 접근 제어자
- 생성자로 만들어놓은 인스턴스의 내부를 추가로 바꾸면? 
  - 개체는 자신의 상태를 스스로 책임져야한다. 
  - 접근 제어자가 이를 가능하게 한다.

- 어떤 외부자들이 개체 속에 접근할 수 있는지 정의
  - public 누구나 접근 가능
  - protected 자신들만 접근 가능
  - 생략할 경우: 같은 패키지에 속한 클래스들만 접근 가능. (같은 패키지: public, 다르면 private) ->> 이는 oop랑은 조금 다르다.
  - private: 외부 접근 금지, 외부에서 접근하면 컴파일 오류.


## 일반적인 접근 제어자
- 멤버 변수는 private 또는 protected
- 메서드는 public
- 멤버 변수 접근은 메서드를 통해서만 해서, 캡슐화, 추상화를 이루다.

### private 메서드는
클래스 내부에서 코드 중복을 막기 위함이다.

### 생성자도 public
- 외부에서 호출해야 하므로.
- 간혹 private가 있을 수도 있다?!

## 패키지 접근 권한
접근 제어자를 사용해주지 않을 때는 패키지 접근 제어자다.
- 같은 패키지 아래 있을 경우 서로 접근할 수 있다.
- 그러나 좋지는 않다.

- 사용할 때는?
  - public 대신 패키지 접근 제어자를 사용할 수 있다면, (개인 라이브러리를 만들 때 등)
  - 내포 클래스를 최상위 클래스로 바꿀 때 쓸 것
  - 

## getter, setter
외부로부터 변수를 지키기 위해! 함수를 통한 변수 접근
- 멤버 변수를 저장하지 않고도 필요할 때마다 getter에서 계산 가능
- setter에서 추가적인 로직을 실행할 수 있다.
- 상속을 통한 다형성 구현이 가능
 
** 소수설에서는 setter 자체가 없어야한다고 하는 주장도 있다. 
변수를 바꿀 수 있다면 구조체랑 다르지않다고 하는 것이다.

### setter 베스트 프랙티스
1. 멤버 변수는 무조건 private
2. 새 개체는 유효하도록. 생성자를 통해 이를 강제 (제대로된 argument 없으면 컴파일 오류)
3. getter는 자유롭게 추가
4. setter는 고민 후에 추가
   - 데이터를 직접 바꾸기 때문에, 가능한 피할 것!
     - 개체가 불확실한 상태로 되는 경우를 최대한 막자.

## 캡슐화
1. 개체의 데이터와 동작을 하나로 묶음
2. 내부의 데이터를 외부로부터 보호

## 추상화: 어떤 구체적인 것에 직접 손대지 않겠다는 의미
1. 추상 자료형 쪽 관점
   - 사용자는 클래스를 자료형으로 사용 가능
   - 그 클래스 내 멤버 변수가 정확히 뭔지 몰라도 된다.
2. 절차적 데이터 추상화쪽 관점
   - 데이터 직접 조작 대신 메서드를 호출

- 단점?
  - 동작 없이 데이터만 있는 클래스는 쓸데없는 코드만 늘어난다.
    - ex: dto
  - 어떻게 추상화를 해야하는지 뚜렷한 객관적 기준이 없다.
    - 이해하더라도 각자 달리 이해하기가 쉽다.




