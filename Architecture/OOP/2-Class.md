## 왜 하필 클래스일까?
자연세계에서의 클래스: 생물학에서 강이라고 부른다. 
이 강은 종이나 과보다 상위 개념이다. 

어떤 개체든지 속한 클래스가 있다는 말이다.

## OOP에서의 클래스
명세서라고 생각하는 게 편하다.

## 간단한 클래스 코드
> public class Human{
>   public String name;
> 
>   public void 함수;
> }

### public
접근 제어자, 멤버 변수, 멤버 함수 모두 있다. 
외부에서 클래스 내부에 담긴 상태와 동작에 접근하는 것을 허용한다.

-> 외부는 다른 패키지를 의미한다.
- 이를 쓰지 않으면 컴파일 오류가 난다!

#### 번외: 상태를 칭하는 용어
멤버 변수, 필드, 속성 등..

#### 번외: 동작을 칭하는 용어
멤버 함수, 메서드, 메시지

### 인스턴스
개체를 부르는 또 다른 표현이다. 
어떤 클래스에 속하는 개체의 한 예라는 뜻이다. 
- 인스턴스화: 클래스로부터 개체 하나를 만드는 행위

개체는 
> Human adam = new Human()

이렇게 만들면, 어떻게 접근할까? 


### 포인터 vs 참조형
- 참조형의 자료형은 사실상 포인터다. 
- 메모리 주소를 저장하는 변수 = 포인터
- 힙에 위치한 Human 개체의 주소를 포함한다.

- 자바는 기본 자료형 제외하고는 포인터가 있다. 
- 포인터 연산이 불가능할 뿐이다.

#### C는 개체를 포인터 혹은 값으로 둘 다 전달이 가능하다. Java는 포인터로만 전달이 가능하다.

### 개체 생성시 멤버 데이터의 초기화
- Java는 0에 준하는 값으로 초기화해준다.
  - 참조형은 널로
- 실수 방지가 중요하기 때문이다.

### .연산자의 다른 의미.
기본적으로 개체의 멤버에 접근할 때 . 연산자를 사용한다. * 연산자 없다.

## 개체의 멤버 함수 호출하기
- 개체 속에 함수가 있으니 역시 .연산자 사용, 호

### 자바에는 free()가 없다. JVM의 가비지 컬렉터가 알아서 치워준다!
#### 자동에는 대가가 있다. 
- 가비지 컬렉터가 메모리를 수집하는 시점을 알 수가 없다. 
- 모든 개체의 사용 여부를 판단하는 게 그리 빠른 연산이 아니다.

따라서, 자원이 한정적인 시스템에는 적합하지않고, 
메모리 누수도 존재한다. (적기는 하다)

## 생성자(constructor)
- 개체 생성 시, 자동으로 호출되는 특수한 함수
- 반환형이 없다.
- 함수명은 클래스명과 동일하다!
> public <class 명>(<매개변수 목록>)
- 이는 오버로딩도 가능하다.
  - 코드 중복이 생길 수 있다. 
  - 코드 중복을 피하려면, this()안에 매개변수 넣어 호출.
    - 매개변수 수가 적은 쪽에서 많은 쪽을 호출
- 생성자가 있는데, 매개 변수를 넣지않으면 컴파일 오류
  - 생성자 없으면, 자동으로 만들어준다. (기본 생성자)

## 생성자로 초기화를 해야하는 이유?
- 처음부터 초기화하거나
- 생성 직후에 어떤 값을 바꿔주거나 -> 실수가 많아진다.
- 생성자는 개체를 만들어주는 계약이다. 최대한 많은 멤버 변수를 초기화해주는 것.
- 외부에서 내부의 데이터를 알 필요 없게 해준다. (데이터 추상화)

## 코드보기: 
- 제일 위에는 package 명 써주기. 안쓰면 컴파일에러

## 접근 제어자
- 생성자로 만들어놓은 인스턴스의 내부를 추가로 바꾸면? 
  - 개체는 자신의 상태를 스스로 책임져야한다. 
  - 접근 제어자가 이를 가능하게 한다.

- 어떤 외부자들이 개체 속에 접근할 수 있는지 정의
  - public 누구나 접근 가능
  - protected 자신들만 접근 가능
  - 생략할 경우: 같은 패키지에 속한 클래스들만 접근 가능. (같은 패키지: public, 다르면 private) ->> 이는 oop랑은 조금 다르다.
  - private: 외부 접근 금지, 외부에서 접근하면 컴파일 오류.


## 일반적인 접근 제어자
- 멤버 변수는 private 또는 protected
- 메서드는 public
- 멤버 변수 접근은 메서드를 통해서만 해서, 캡슐화, 추상화를 이루다.

### private 메서드는
클래스 내부에서 코드 중복을 막기 위함이다.

### 생성자도 public
- 외부에서 호출해야 하므로.
- 간혹 private가 있을 수도 있다?!

## 패키지 접근 권한
접근 제어자를 사용해주지 않을 때는 패키지 접근 제어자다.
- 같은 패키지 아래 있을 경우 서로 접근할 수 있다.
- 그러나 좋지는 않다.

- 사용할 때는?
  - public 대신 패키지 접근 제어자를 사용할 수 있다면, (개인 라이브러리를 만들 때 등)
  - 내포 클래스를 최상위 클래스로 바꿀 때 쓸 것
  - 



