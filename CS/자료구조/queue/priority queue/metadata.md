## 구현 방법
- 배열 기반
- 연결 리스트 기반 
- 힙

배열이나 연결리스트로 구현하면 상당히 간단히 구현이 가능하다.
그런데 배열의 경우, 
1. 데이터를 삽입 혹은 삭제하는 과정에서 한 칸씩 뒤로 밀거나 앞으로 당겨야 하는 문제가 있다. 
2. 더불어 삽입의 위치를 찾기위해 배열의 모든 데이터와 우선순위 비교를 해야할수도 있다. 

2번 문제는 연결리스트도 마찬가지로 가지고 있는 문제다. 
이는 데이터의 수가 많아지면 더 큰 문제다. 그래서 힙으로 우선순위 큐를 구현하는 것이 일반적이다.

## 힙이란?
이진 트리인데 완전 이진 트리인 것. 
그리고 모든 노드에 저장된 값은 자식 노드에 저장된 값보다 크거나 같아야한다.

루트 노드로 갈 수록 저장된 값이 커지면 최대 힙, 작아지면 최소 힙이라한다.

### 데이터 삽입 과정
새 데이터를 우선순위가 제일 낮다는 가정하에 마지막 위치에 저장한다. 그러고는 부모 노드와 우선순위를 비교하여 위치가 바뀌어야한다면 바꾸어준다.

### 데이터 삭제 과정
마지막 노드를 루트 자리의 자리로 옮기고, 자식 노드와의 비교를 통해 제자리를 찾아가게 한다.

### 성능 평가
삽입 시간 복잡도도 log, 삭제도 log다. 그 이유는 트리의 높이에 해당하는 수만큼만 비교 연산을 진행하면 되기 때문이다.

### 힙의 구현에 어울리는 것은 연결리스트가 아니다.
물론 트리를 구성하는 데에는 연결리스트가 사용되었었다. 그러나, 연결리스트를 사용하면 힙 특유의 '새 노드를 힙 마지막 위치에 위치'시키는 것이 쉽지가 않다.

배열로 구현하되, 인덱스가 0인 위치에 배열 요소는 사용하지 않고, 왼쪽과 오른쪽 자식 노드, 부모 노드의 인덱스 값을 얻는 방법을 알아야한다. 

- 왼쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 * 2
- 오른쪽 자식 노드의 인덱스 값 = 부모 노드의 인덱스 값 *2 +1
- 부모 노드의 인덱스 값 = 자식 노드 인덱스 값 / 2

## 간단히 구현해본 힙
- simple 폴더에서 확인할 수 있듯이, 간단하게 구현은 하고있지만 힙 엘리먼트를 생성할 때 우선순위를 함께 작성해주어야해서 불편하다. 이를 조금 더 유용하게 발전시킬 수 있다.
- data의 크기에 따라 우선순위를 달리한다고 가정했을 때, 해당 함수를 함수 포인터로 힙에 설정만 해주면, 그 함수로 데이터 삽입 혹은 삭제시 비교를 진행해 힙 구조를 구성할 수 있다. 
- 우선순위 큐는 이 변형된 힙과 똑같은 구조다. 


