# 1. 버블 정렬
인접한 두 개의 데이터를 비교해가며 정렬을 진행한다. 

## 성능
- 비교의 횟수와 이동의 횟수 모두를 고려해야한다. 
- O(n^2)

# 2. 선택 정렬
정렬 순서에 맞게 하나씩 선택해서 옮기는 알고리듬. 
정렬 순서 상 가장 앞선 것을 선택해서 가장 왼쪽으로 이동시키고, 원래 그 자리에 있던 데이터는 빈자리에 가져다 놓는다. 
## 성능
- 비교의 횟수와 이동의 횟수 모두를 고려해야한다. 
- 비교의 경우 O(n^2)로 버블과 동일하지만, 이동의 경우, 이중 for문 안쪽에 위치하는 것이 아니라, 바깥쪽 for문에 위치하므로 이동횟수는 O(n)이 된다. 
- 그러나 최악의 경우와 최선의 경우 모두 다르므로 버블과의 비교는 무의미하다.

# 3. 삽입 정렬
개선된 선택 정렬과 유사! 
정렬 대상을 정렬 된 부분과 안 된 부분 둘로 나누고, 정렬 안 된 부분의 데이터를 정렬된 부분의 특정 위치에 삽입해 가며 정렬을 진행하는 알고리듬.

## 성능
데이터가완전히 정렬된 상태라면 안쪽 for문이 실행되지 않지만, 최악의 경우 break문을 실행하지 않아 O(n^2)

# 4. 힙 정렬
힙을 이용한 정렬 방식이다. 
힙의 루트 노드에 저장된 값이 가장 커야한다라는 특성을 활용하여, 힙의 루트 모드에 저장된 값이 정렬 순서상 가장 앞서도록 힙을 구성해볼 수 있다. 

## 성능
힙의 데이터 저장 시간 복잡도 O(logn) 삭제 시간 복잡도 O(logn) 둘을 합하면 2O(logn)

그리고, 정렬 대상의 수가 N개라면 O(nlogn)

# 5. 병합 정렬
분할 정복이라는 알고리즘 디자인 기법에 근거하여 만들어진 정렬 방법이다. 
분할 정복이란, 복잡한 문제를 복잡하지 않은 문제로 분할하여 정복하는 방법이다. 그런데 분할해서 정복한 뒤에는 결합의 과정을 거쳐야해서, 총 3단계라 할 수 잇다. 

병합 정렬은 데이터가 1개만 남을 때까지 분할을 해나간다. 데이터가 두개만 남아도 정렬을 할 필요가 있지만 데이터가 한개만 남으면 그조차 불필요해지기 때문이다. 

이는 기존의 정렬 함수들과는 시그내처가 다르다. 정렬의 범위를 지정하게된다. 그 이유는 정렬의 대상을 재귀적으로 반으로 나눠야하기 때문이다. 

## 성능
병합 정렬에서 진행되는 최대 비교연산의 횟수는, O(nlogn). 비교를 두번하게 된다. 
이동의 경우 임시 배열에 데이터 병합하는 과정에서와 임시 배열에 저장된 데이터 전부를 원위치로 옮기는 과정에서 비교연산 횟수의 두배에 해당하는 이동연산이 이루어진다. 2배는 무시해도되므로 O(nlogn)

임시 메모리가 필요하다는 단점이 있지만, 배열이 아닌 연결리스트로 이를 구현한다면 그런 단점도 없다.

# 6. 퀵 정렬
이 또한 병합 정렬에서처럼 분할 정복에 근거하여 만들어진 정렬 방법이다.

평균적으로 매우 빠른 정렬의 속도를 보이는 알고리즘이다. 
- 정렬 대상의 가장 왼쪽 지점과 오른쪽 지점
- 중심축 pivot (정렬의 기준)
- 피벗 제외한 가장 왼쪽 지점을 가리키는 low, 피벗보다 정렬의 우선순위가 낮은 데이터 만날 때까지 오른쪽으로 이동시킨다. 만나면 high가 가리키는 값고 교환한다. 
- 피벗 제외한 가장 오른쪽 지점을 가리키는 high, 피벗보다 정렬의 우선순위가 높은 데이터 만날 때까지 왼쪽으로 이동시킨다. 만나면 low가 가리키는 값과 교환한다.
- 계속 반복하다가 low, high가 서로 교차하면 high와 pivot 값을 서로 교환한다. 이렇게 되면 pivot이 제 위치를 찾게된다. 

- 피벗이 중간에 해당하는 값일 경우 정렬대상은 균등하게 나뉜다. 그래서 정렬대상에서 세개의 데이터를 추출하여 그 중 중간값ㅇ체 해당하는 것을 피벗으로 선택한다.

## 성능
분할은 log로 행해진다 (피벗에 의하여), 그리고 데이터 수는 n개 이므로 비교 연산 횟수는 O(nlogn).

만약 피벗이 적절한 수로 선택되지 않게된다면 O(n^2)이지만 보통은 그렇게 진행되지 않는다. 
평균적으로 제일 빠른 것으로 알려져있고, 그는 퀵 정렬의 데이터 이동횟수가 상대적으로 적고, 별도의 메모리 공간이 필요없기 때문이다. 

# 7. 기수 정렬
정렬 순서상 앞서고 뒤섬의 판단을 위한 비교연산을 하지 않는다. 
이론상 성능의 한계는 O(nlogn)으로 알려져있는데, 기수 정렬은 이 한계를 넘어설 유일한 알고리듬이다. 

대신 데이터의 길이가 같아야한다. 만약 데이터 길이가 다르다면 데이터의 가공을 위한 별도의 알고리즘을 고안해야한다. 

여기서 기수란 주어진 데이터를 구성하는 기본 요소를 의미한다. 10진수는 0부터 9까지의 숫자 조합으로 데이터를 표현하니, 해당 수들이 10진수의 기수가 된다. 

기수 정렬이란, 데이터를 구성하는 기본 요소, 즉 기수를 이용해서 정렬을 진행하는 방식이다. 

- LSD(Least Significant Digit) 기수 정렬과 MSD(most ~) 기수 정렬이 있다. LSD 쪽이 구현의 편의성이 더 높다. 성능은 MSD 쪽이 높다고 생각할수는 있지만 그렇지않다. 빅 오가 같은데다 모든 데이터에 일괄적인 규칙을 적용할 수 없기에 추가적 연산과 메모리가 요구된다는 점을 감안하면 굳이 MSD 방식을 사용할 필요는 없다.


## 성능
비교연산이 핵심이 아니고, 버킷으로의 데이터 삽입과 추출이 핵심이다. 따라서 정렬 대상의 수 n과 길이를 l이라 할 때, O(ln)이 정렬 빅오다. 이는 O(n)과 같다.