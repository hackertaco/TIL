정렬알고리듬이란, 목록 내 저장된 요소들을 특정한 순서대로 재배치하는 알고리듬. 이를 하는 이유는 사람이 읽기 편하도록, 그리고 더 중요한 이유는 좀 더 효율적인 알고리듬을 사용하기 위해서다.
배열과 같은 데이터 구조에 저장되어있다는 것을 가정하고, 임의의 접근을 허용한다.

다양한 정렬 알고리듬이 있다. 그 알고리듬끼리의 차이는, 시간 복잡도나 메모리 사용량, 안정성 등이 있다.
직렬과 병렬 차이도 있다.

그런데 안정성이란 ? (stable)
이는 똑같은 키를 가진 데이터들의 순서가 바뀌지 않느냐의 여부다. ex. 3과 3 두개가 겹치게 될 때!
이 안정성을 신겅쓰지 않는다면, 버그가 난다.

이 안정성이 문제가 되는 경우는, 사용하는 키와 그 키가 가리키는 값이 다를 경우다.
혹은, 구조체나 클래스의 일부 멤버만 정렬 키로 사용할 때도 그러하다.

## 대표적인 정렬 알고리듬

버블과 선택 정렬은 언제든지 구현할 수 있어야한다.
퀵 정렬은 언제든지 설명할 수 있어야한다.
병합 정렬과 힙 정렬은 이해하는 정도로 충분하다.

이 정렬 알고리듬은 아무리 빨라도 최소 한번씩은 방문해야한다.

-   O(N)보다는 느리다. 아무리 빨라도 O(NlogN)

-   버블 평균과 최악 모두 O(N^2)
-   선택 평균과 최악 모두 O(N^2)
-   삽입 평균과 최악 모두 O(N^2)
-   퀵 O(NlogN)/O(N^2)
-   병합 O(NlogN)/O(NlogN)
-   힙 O(NlogN)/O(NlogN)

그런데 퀵을 제일 많이 쓴다. 이유는 일단 메모리가 O(logN). 메모리 할당과 삭제가 몹시 빠르다. 스택에서 일어난다.
병합은 메모리를 하나 만들어서 O(N), 힙의 경우 근데 O(1) 인데? 그런데 시간 복잡도와 실행 시간은 다르다. 평균으로 봤을 때는 언제나 퀵이 빠르고,(N이 작은 편이다.) 그리고 퀵 정렬에서 최악이 나올 확률이 상당히 작다.

## 상황에 따른 정렬 알고리듬 선택

기본적으로 퀵 정렬 사용할 것. C도 qsort 함수를 기본 제공한다.
간단히 구현할 때는 버블 정렬 사용.
어떠한 경우에도 느려지면 안 될 때, 병합 또는 힙 정렬을 사용한다.
특수한 상황에 적합한 Radix 정렬도 있다. 실무에서 필요에 따라 사용하면 된다.

### 버블 정렬

가장 간단한 정렬 알고리듬 중 하나.
이웃 요소 둘을 비교해서 올바른 순서로 고치는 과정을 반복한다.
한 번 목록을 순회할 때마다 가장 큰 값이 제일 위로 올라간다.

제일 끝에 위치한 요소는 더이상 탐색하지 않는다는 특징이 있다.

목록을 훑는 횟수 n-1, 평균 방문 횟수 n/2
새로 만든 목록 없으므로 O(1)
순서를 바꾸지 않으므로 안정적.

```java
public static void bubbleSort(int[] nums)
{
    for(int i = 0; i < nums.length-1; ++i){
        for(int j = 0; j < nums.length-i-1; ++j){
            if(nums[j] > nums[j+1])
            {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
}
```

### 선택 정렬

가장 사람들이 생각하는 방식과 비슷한 것이다.
이 또한 목록을 훑는데, 최솟값을 찾아 선택한다고 보면 된다.

```java
public static void selectSort(int[] nums)
{
    for(int i = 0; i < nums.length-1; ++i){
        int max = i;
        for(int j = i+1; j < nums.length; ++j){
            if(max > j){
                max = j;
            }
        }
        // 이중 포문 내에서 swap을 진행하지 않는다!
        int temp = nums[max];
        nums[max] = nums[i];
        nums[i] = temp;

    }
}
```

### 삽입 정렬

현재 위치의 요소를 뽑고, 이를 과거에 방문했던 요소 중 어디 사이에 넣어야 정렬이 유지되는지 판단한 후 그 위치에 삽입한다. 해당 삽입으로 인해 다른 요소들을 오른쪽으로 밀어야할 수도 있다.

외부 반복문의 반복 횟수는 고정, 내부 반복문의 반복 횟수는 가변적이다. while 문이 적합하다.

```java
public static void insertSort(int[] nums)
{
    for(int i = 0; i < nums.length-1; ++i){
        int j = i + 1;
        while(nums[i] > nums[j]){
            int temp = nums[j];
            nums[j] = nums[i];
            nums[i] = temp;
            j++;
        }
    }
}
```

### 퀵 정렬

주먹구구식이 아닙니다!

-   진정한 분할 정복 알고리듬.
-   어떤 값, 피봇을 기준으로 목록을 하위 목록으로 2개로 나눈다.
-   목록을 나누는 기준은 피봇보다 작냐 혹은 크냐!
-   배열의 제일 오른쪽 요소를 기준으로, 해당 값보다 작은 요소가 있다면 좌를 오른쪽으로 밀고, 크다면 해당 자리에 계속 있는 방식을 반복하여 모든 요소 탐색이 끝나면 좌가 가리키는 요소와 피봇 값의 위치를 바꾼다.

```java
public static void quickSort(int[] nums)
{
    quickSortRecursive(nums, 0, nums.length - 1);
}

public static void quickSortRecursive (int[] nums, int left, int right)
{
    if(left >= right)
    {
        return;
    }
    int pivotPos = partition(nums, left, right);
    quickSortRecursive(nums, left, pivotPos - 1);
    quickSortRecursive(nums, pivotPos + 1, right);
}

public static int partition(int[] nums, int left, int right){
    int pivot = nums[right];

    int i = (left -1);
    for(int j = left; j < right; ++j){
        if(num[j] < pivot){
            ++i;
            swap(nums, j, j);
        }
    }
    int pivotPos = i+ 1;
    swap(nums, pivotPos, right);
    return pivotPos;
}
```

최악의 상황: 분할할 때마다, 기준값의 최종 위치가 한쪽 끝인 경우.
이를 피하기 위해서는 제일 끝이 아닌 다른 위치를 기준 값으로 뽑으면 된다. 어느 경우에도 최악의 상황은 있다.

매 단계마다 랜덤하게 위치하게 하는 경우 모든 경우에 작동할 수도 있다. 근데 최악의 상황만 골라가는 것이 매우 작은 확률이긴 하다. 근데 최종으로 그를 허용할 수 없다고 할 때 다른 정렬을 사용해야한다.

그런데 그러면 코드가 작동 안할수도 있다.

공간복잡도: 실제 원본 배열을 고치므로 O(1). 함수 호출 깊이만큼 스택메모리를 사용하고 스택 메모리라 할당과 해제가 빠르다. O(logN)

quickSortRecursive에서 재귀 함수를 두번 호출하게 되는데, 두번째 호출은 꼬리 재귀로 만들어 두번 호출을 피할 수는 있다.

## 병합 정렬

이미 정렬된 배열을 합쳐서 새로운 배열을 만드는 것이 목적!
이미 정렬된 배열을 합치는 것은 효율적이다. 그러나, 배열 하나를 새로 만들기 때문에 공간 복잡도가 O(N)

원본 배열을 정렬된 여러 배열들로 만들어야한다.
나눌 때는 재귀적으로. O(logN), 거꾸로 합치게 되면 O(N), 둘을 곱하여 O(nlogN)

매우 단순하고 기발하다.

## 힙 정렬

힙을 사용하는 정렬 알고리듬. 언제나 부모의 키가 자식의 키와 같거나 크다.

삽입은 제일 나중의 리프에서, 제거는 제일 부모부터! 그리고 제일 마지막 자식을 그 자리에 넣어서 힙 속성 만족하도록 재정렬.
나쁘지않은데, 힙 만드는 것이 조금 귀찮아서 덜 쓰는 것으로 보임.
