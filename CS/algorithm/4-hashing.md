너무도 소중한 해시! 몹시 근본이 되는 알고리듬 중 하나!

예를 들면, 데이터 저장할 위치를 찾거나, 길이가 긴 데이터 둘을 빨리 비교를 하거나, 누출되면 곤란한 데이터의 원본을 저장하지 않기 위하여 등! 많은 경우에 사용된다.

다양한 개념으로 사용되지만, 해시 함수의 정의는 임의의 크기를 가진 값을 고정 크기의 값에 대응시키는 함수다. 여전히 함수이므로 수학에서의 함수의 정의 즉, 일대일 대응이 맞아야한다. (반드시 일대일 대응은 아닐수도 있다.) 입력값이 같으면 언제나 출력값도 같아야한다.

-> 해시 함수의 모든 필수요건.

## 해시 알고리듬 분류

-   (비암호학적)해시 함수
-   암호학적 해시 함수

## 속성 1: 균일성

엄밀하게 말하면, 균일 분포를 말한다.
입력값을 다양하게 넣었을 때, 출력값이 고르게 분포될수록 균일성이 높다고 말한다. -> 해시 충돌이 적어야한다는 의미.

완벽한 해시함수란, 해시 충돌이 전혀 없는 함수를 말한다.

이를 측정하기 위해, **카이제곱 검정**이라는 것을 이용한다. 해당 결과가 0.95에서 1.05 사이라면 균일한 분포를 가진 해시함수라고 본다. : 실무에서 크게 사용되지는 않는다.

해시값이 덜 중복되게 버킷 수를 정하거나(소수를 사용해서) 완벽한 눈사태가 나도록 해시함수를 설계하는 것이 실무에서 사용된다. 눈사태란, 입력값이 약간만 바뀌어도 출력값이 굉장히 많이 바뀌는 것을 의미한다. 보통 암호학적 알고리듬이 매우 선호하는 효과다.

### 지역민감해시

해시 충돌의 최소화 대신 최대화를 목표로! 엄청나게 많은 데이터에서 비슷한 것들을 찾는 용도다. 스팸 메일찾거나, 웹 검색 엔진에서 비슷한 문서를 추천하거나, 저작권 침해를 검사할 때 이용한다.

비슷한 내용을 가진 데이터끼리 충돌해야한다!

## 속성 2: 효율성

당연히 빠를수록 좋다. 공간을 더 낭비해도 빠른 접근 속도를 선호한다. 충돌이 좀 더 나더라도 더 빠른 함수를 선호한다.

그런데, 하드웨어 가속이 어려운 해시를 선호하는 경우도 있다. (암호학적 해시 알고리듬)

### 비암호학적 해시 함수

해시 함수를 만들었는데, 보안적으로는 문제 없을 경우에 주로 사용한다. 그냥 데이터 저장 및 찾기, 고유한 id 생성과 같은 경우.

모든 데이터에 대해 최고의 결과를 보장하는 해시 함수는 존재하지 않는다. 입력값에 따라 다른 해시함수를 사용하는 확률적 알고리듬은 존재한다. (유니버설 해싱)

따라서, 용도에 맞는 해시 함수를 사용하는 것이 중요하다. 자바에서 hashcode 구현을 각 클래스에 맡긴 이유가 그러하다. 비트 패킹도 해시 함수로 사용이 가능하다.

해시 함수를 스스로 발명하는 경우는 비트 패킹 말고는 흔치 않다. 우리가 집중할 부분은, 어떤 연산들이 좋은 해시 함수를 만들고 어떤 해시 함수를 사용해야하는지다!

### 올바른 해시 함수를 고르는 법

1. 실제로 가지고 있는 데이터로 테스트하면서 측정을 한다.
    - 속도(실제로 컴퓨터에서 도는 속도), 해시 충돌 수, 메모리, 균일성 측정
2. 구글에게 물어본다. 내 데이터들이 일반적인 데이터인 경우!

### Lose Lose 해시

가장 최악의 해시함수. 실제 실무에 쓰는 것은 아니다. 그저 어떻게 해시함수를 만드는지 예시.
바이트를 더하는 해시함수.

속도도 느리고, 충돌이 많다. 매우 간단하다.

덧셈만으로는 좋은 해시함수가 안 나온다는 대표적 예시

### Murmur 해시

비트시프트, xor, 곱하기를 이래저래 반복해서 나쁘지 않은 해시함수를 만들어낸다.

### FNV-1 해시

오히려 머머 해시보다 복잡하지 않다.
소수를 곱하고 일부러 오버플로를 내고, xor를 하는 식으로 하기만 했는데도, murmur보다 복잡하지 않다. 그리고 빠르다.  
파이썬에서도 기본으로 사용한 해시함수.

xor는 cpu에서 굉장히 빠른 연산 중 하나다.

### 체크섬

해시 알고리듬의 일부라고 볼수도 있고 아닐수도 있다.
여러 데이터로부터 도출한 작은 크기의 데이터 하나. 데이터의 모든 바이트를 어떤 방식으로든 합한다. 출력값의 크기가 고정되어있으면 해시함수기 때문에, 해시함수랑 비슷한 개념이다.

저장 혹은 전송 중에 발생한 오류를 찾아낸다.
처음 저장할 때 체크섬 계산해서 저장하고, 나중에 데이터 읽을 때 다시 체크섬을 계산한다. 처음과 다르면 오류가 난다.

-   사용례
    주민등록 번호 유효성 검사할 때! 예전에 주민등록번호의 마지막 숫자의 공식이 있었다.

신용카드 번호 마지막 숫자! 룬 알고리듬으로 만들었다.

ISBN(책 번호) 유효성 검사도 마찬가지다.
