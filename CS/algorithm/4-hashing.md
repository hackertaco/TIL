너무도 소중한 해시! 몹시 근본이 되는 알고리듬 중 하나!

예를 들면, 데이터 저장할 위치를 찾거나, 길이가 긴 데이터 둘을 빨리 비교를 하거나, 누출되면 곤란한 데이터의 원본을 저장하지 않기 위하여 등! 많은 경우에 사용된다.

다양한 개념으로 사용되지만, 해시 함수의 정의는 임의의 크기를 가진 값을 고정 크기의 값에 대응시키는 함수다. 여전히 함수이므로 수학에서의 함수의 정의 즉, 일대일 대응이 맞아야한다. (반드시 일대일 대응은 아닐수도 있다.) 입력값이 같으면 언제나 출력값도 같아야한다.

-> 해시 함수의 모든 필수요건.

## 해시 알고리듬 분류

-   (비암호학적)해시 함수
-   암호학적 해시 함수

## 속성 1: 균일성

엄밀하게 말하면, 균일 분포를 말한다.
입력값을 다양하게 넣었을 때, 출력값이 고르게 분포될수록 균일성이 높다고 말한다. -> 해시 충돌이 적어야한다는 의미.

완벽한 해시함수란, 해시 충돌이 전혀 없는 함수를 말한다.

이를 측정하기 위해, **카이제곱 검정**이라는 것을 이용한다. 해당 결과가 0.95에서 1.05 사이라면 균일한 분포를 가진 해시함수라고 본다. : 실무에서 크게 사용되지는 않는다.

해시값이 덜 중복되게 버킷 수를 정하거나(소수를 사용해서) 완벽한 눈사태가 나도록 해시함수를 설계하는 것이 실무에서 사용된다. 눈사태란, 입력값이 약간만 바뀌어도 출력값이 굉장히 많이 바뀌는 것을 의미한다. 보통 암호학적 알고리듬이 매우 선호하는 효과다.

### 지역민감해시

해시 충돌의 최소화 대신 최대화를 목표로! 엄청나게 많은 데이터에서 비슷한 것들을 찾는 용도다. 스팸 메일찾거나, 웹 검색 엔진에서 비슷한 문서를 추천하거나, 저작권 침해를 검사할 때 이용한다.

비슷한 내용을 가진 데이터끼리 충돌해야한다!

## 속성 2: 효율성

당연히 빠를수록 좋다. 공간을 더 낭비해도 빠른 접근 속도를 선호한다. 충돌이 좀 더 나더라도 더 빠른 함수를 선호한다.

그런데, 하드웨어 가속이 어려운 해시를 선호하는 경우도 있다. (암호학적 해시 알고리듬)

### 비암호학적 해시 함수

해시 함수를 만들었는데, 보안적으로는 문제 없을 경우에 주로 사용한다. 그냥 데이터 저장 및 찾기, 고유한 id 생성과 같은 경우.

모든 데이터에 대해 최고의 결과를 보장하는 해시 함수는 존재하지 않는다. 입력값에 따라 다른 해시함수를 사용하는 확률적 알고리듬은 존재한다. (유니버설 해싱)

따라서, 용도에 맞는 해시 함수를 사용하는 것이 중요하다. 자바에서 hashcode 구현을 각 클래스에 맡긴 이유가 그러하다. 비트 패킹도 해시 함수로 사용이 가능하다.

해시 함수를 스스로 발명하는 경우는 비트 패킹 말고는 흔치 않다. 우리가 집중할 부분은, 어떤 연산들이 좋은 해시 함수를 만들고 어떤 해시 함수를 사용해야하는지다!

### 올바른 해시 함수를 고르는 법

1. 실제로 가지고 있는 데이터로 테스트하면서 측정을 한다.
    - 속도(실제로 컴퓨터에서 도는 속도), 해시 충돌 수, 메모리, 균일성 측정
2. 구글에게 물어본다. 내 데이터들이 일반적인 데이터인 경우!

### Lose Lose 해시

가장 최악의 해시함수. 실제 실무에 쓰는 것은 아니다. 그저 어떻게 해시함수를 만드는지 예시.
바이트를 더하는 해시함수.

속도도 느리고, 충돌이 많다. 매우 간단하다.

덧셈만으로는 좋은 해시함수가 안 나온다는 대표적 예시

### Murmur 해시

비트시프트, xor, 곱하기를 이래저래 반복해서 나쁘지 않은 해시함수를 만들어낸다.

### FNV-1 해시

오히려 머머 해시보다 복잡하지 않다.
소수를 곱하고 일부러 오버플로를 내고, xor를 하는 식으로 하기만 했는데도, murmur보다 복잡하지 않다. 그리고 빠르다.  
파이썬에서도 기본으로 사용한 해시함수.

xor는 cpu에서 굉장히 빠른 연산 중 하나다.

### 체크섬

해시 알고리듬의 일부라고 볼수도 있고 아닐수도 있다.
여러 데이터로부터 도출한 작은 크기의 데이터 하나. 데이터의 모든 바이트를 어떤 방식으로든 합한다. 출력값의 크기가 고정되어있으면 해시함수기 때문에, 해시함수랑 비슷한 개념이다.

저장 혹은 전송 중에 발생한 오류를 찾아낸다.
처음 저장할 때 체크섬 계산해서 저장하고, 나중에 데이터 읽을 때 다시 체크섬을 계산한다. 처음과 다르면 오류가 난다.

-   사용례
    주민등록 번호 유효성 검사할 때! 예전에 주민등록번호의 마지막 숫자의 공식이 있었다.

신용카드 번호 마지막 숫자! 룬 알고리듬으로 만들었다.

ISBN(책 번호) 유효성 검사도 마찬가지다.

체크섬 알고리듬은 매우 간단하지만 모든 오류를 찾지는 못한다.
데이터 변경에 대해서만 확인한다. 복구는 보통 신경쓰지않는다. 따라서 체크섬이 일치하지 않으면 ? 재전송 요청을 한다거나 할 수 있다.

### 패리티 비트

이도 체크섬의 개념 중 일부다. 이진수로 저장된 데이터에 1비트짜리 체크섬을 추가한다. 비트가 뒤집히지 않았냐를 확인한다. 보통 1바이트 단위로 많이 사용하게 된다. 패리티의 개수가 홀수인지 짝수인지로 나눈다.

### 순환 중복 검사

이 또한 체크섬 알고리듬 중 하나다.
다항식의 나머지 연산을 이용해 검사값을 만든다. 어떤 다항식을 사용하냐에 따라서 이름이 결정된다.

즉 다항식의 최고차항에 따라 CRC에 사용하는 비트 수가 달라진다.

최고차항의 계수는 언제나 1. 그래서 언제나 해당 계수 생략해도된다.

이는 원래 값에 XOR를 해서, 전체가 0이 나올때까지 계산 반복하고 마지막에 나온 수가 체크섬으로 계산을 하게된다. 8, 16, 32, 64 등을 사용한다.

## 암호학적 해시 알고리듬

해시값에서 원본 값을 찾는 것이 불가능한 알고리듬.
출력값으로 입력값을 유추할 수는 없다.

원본 값을 찾으려면 모든 조합을 모두 시도해봐야한다. 보안 분야에서 다양한 용도로 사용한다.

그런데 더는 안전하지 않은 것들도 있다.

메시지나 파일의 무결성 검사, 디지털 서명 생성 및 검증, 비밀번호 검증, 작업증명

-   해시값으로부터 원본 데이터를 찾기가 어려워야함. 해시 값으로부터 패턴을 보기가 어려워야한다.
-   똑같은 해시값이 나오는 다른 입력값을 찾기 어려워야함.
-   해시값이 같은 두 입력값을 찾기가 어려워야함.
    -   이것이 쉬우면 충돌 공격이 쉬워지고, 충돌 공격은 무차별 대입 공격보다 쉽다.
    -   생일 문제: 해시값의 길이가 길수록 좋다는 예시. 동일한 생일을 가지는 사람 수를 말한다.
