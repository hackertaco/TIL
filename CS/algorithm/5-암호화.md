평문 -> 암호문 변환: 암호화라 한다.

평문은 누구나 읽으면 곧바로 이해할 수는 있는 정보. 암호문은 읽는다고 모두가 이해할 수는 없는 정보.

암호문도 누군가 훔쳐볼 수는 있으나, 특별한 정보를 아는 사람만 이해할 수 있다. 암호화에 사용한 방법을 알아야 빨리 복호화가 가능하다.

해시 알고리듬과의 차이점이라 하면, 해시 알고리듬은 원문 복구를 막고자 하지만 암호화 알고리듬은 원문 복구를 허용해야한다.

### 암호화의 역사

고대시절부터 사용!

매일 글자 목록이 바뀌는 에니그마 기계도 글자 교환 방식

평화시대라서 암호화가 필요없다 생각하면 금물. 전화 혹은 온라인을 통해 타인과 대화하는 일이 많아졌고, 온라인에 저장된 정보가 너무 많기에 현재는 모든 것을 암호화해야한다.

현재는 글자 교환 방식도 BFS로 다 뚫린다!

### 정수론

안 뚫리게 하려면 어떻게 해야할까?

수학적으로 인텐시브. 2진수로 표현된 데이터를 암호화하려다보니, 갑자기 주목받은 분야.

소수에 관련된 정수론적 알고리듬이 많은 주목을 받음.

-   매우 큰 정수: 32비트 범위 안의 소수(203,280,220개뿐이라, 적다)
-   그래서 입력크기 N으로! 비트 수를 N으로 둔다.
-   곱셈 나눗셈 나머지 연산의 시간 복잡도 -> 원래는 O(1)인데, 암호학에서 사용하는 정수는 비트 수에 비례.

현재 암호화 알고리듬 두 종류

1. 대칭 키 암호화 : 암호와 복호에 동일한 키 사용
2. 비대칭 키 암호화: 키가 다름

### 대칭 키 암호화

둘다 같은 키를 사용한다. (암호와 복호)

이 키는 메시지 송-수신자가 공유하는 비밀이어야한다.

가장 간단한 예: XOR(스트림 암호, 각 바이트에 적용하는 키가 달라야 안전하다. 그래서 시드를 두고 난수 생성. 설정이 복잡!), 와이파이

블록암호라는 것도 있다. 정해진 블록크기 만큼의 바이트를 한번에 암호화.

### 유명한 대칭 키 알고리듬 - AES

가장 많이 사용되는 대칭 키 알고리듬.

NSA에서 유일하게 승인. 현재 가장 널리 사용되는 대칭 키 알고리듬. 블록 크기는 128비트. 128, 192, 256비트로 나뉜다.
키 길이에 따라 평문을 암호문으로 변환하는 라운드 수가 다르다.

한번에 16바이트씩 읽는다. 4\*4 행렬로 배치한다. 그 뒤 여러 처리 과정을 통해 처리
128비트 평문을 여러 라운드를 거쳐서, 최종라운드에서 암호가 나온다.

#### 내부 연산
암호화 키(대칭키)로부터 각 라운드에 사용할 여러 키를 생성하게 된다. 대칭 키는 129, 192, 256비트라고 할지라도 그로부터 생성한 라운드 키는 모두 128비트다. 
- 0 라운드: 라운드 키 더하기, 원문에 0 라운드 키를 더한다. 단순히 숫자말고 배타합을 더한다. (xor). 원문을 아스키 16진수로 바꿔주고 그를 라운드 키와 xor 해준다. 라운드 키 더하기의 목적은 송 수신자만 알 수 있는 키로 원본 메시지를 숨기는 것이다.
- 1라운드 ~ : 이전 라운드의 결과를 입력값으로 사용하게된다. 그리고 각 바이트를 다른 바이트로 대체하는데, 룩업테이블을 사용한다. 이 테이블을 사용하게 되면 어떤 단순 사칙 혹은 비트 연산이 아니므로, 혼돈 효과를 성취할 수 있다. 그렇게 변환하고 나면 그를 행 이동을 하게되는데, 1행은 이동없고, 2행은 1, 3행은 2, 4행은 3만큼 왼쪽으로 바이트 시프트한다. 이는 확산 효과를 성취한다. 열도 섞는다. 각 열에 있는 4바이트를 선형적으로 변환한다. 행렬(4*4)과 벡터 곱을 이용한다. ex. c5*2+0E*3+cd*1+02*1. 근데 그냥 합이 아니라, 배타합! 곱도 그냥 곱이 아니라 곱셈 규칙이 있다. 1로 곱하면 일반적 곱셈과 동일하고, 2로 곱하면 원래 값에 2를 곱하여 (=왼쪽으로 1만큼 비트 시프트) 원래 값의 최고 비트가 1이었다면, 1B로 xor(최고비트가 아까우므로 어떻게든 다시 반영하기 위하여.) 3으로 곱하면 2로 곱하는 규칙과 1로 곱하는 규칙을 배타합 시킨다.
바이트를 더하고, 각 바이트를 다른 바이트로 대체, 행도 왼쪽으로 이동, 각 열에 있는 4바이트를 선형적으로 변환. 이 또한 행 이동과 마찬가지로 확산 효과를 성취한다. 
- 최종 라운드는 바이트도 대체, 행 이동, 라운드 키 더하기를 다시 실행. 그 결과가 최종 암호문. 
- 복호화는 그를 반대로 하면 된다. 

#### AES code

- java 자체에서의 코드가 있다.


## 비대칭 키 암호화

역사적으로는 대칭 키가 먼저 나왔다. 이건 조금 더 어려운!

대칭키는 암호화와 복호화에 동일한 키를 사용해서 가끔 발목이 잡히기 대문에, 보안 문제없이 쉽게 키를 배포할 수 있는 방법이 필요하다.

복호화에 사용할 키를 완전히 공해! 수학의 힘을 빌려 안전하게 만들게 된다.

송신자가 수신자의 공개 키로 암호화. 공개 키로는 암호문에서 원문 변환이 불가하다.
수신자는 자신의 비밀 키로 복호화를 한다.

전송하는 메시지의 암호화를 하거나 (위의 방식),전자서명에 이를 사용한다.(위의 방식과는 다르게 비밀키로 암호화) 메시지 송신자가 올바름을 증명! 이 때는 메시지는 누구든 볼 수 있다.

### 어디서 사용하는가? 
거의 모든 곳에서!
- HTTPS: 비대칭 키 암호화를 사용해서 보내는 모든 리퀘스트를 암호화. 
- 비밀 채팅 모드: 서버도 내 비밀키를 모르는 모드
- 비트코인 등의 암호화폐 프로토콜
- Git 커밋의 전자서명

다양한 기법들이 있는데, 
대표적인 것이 RSA. 

### RSA
정수론에 기초. 
- 공개 키와 비밀 키 쌍을 만드는 게 매우 쉽다. 매우 큰 두 소수를 이용한다. 공개키를 안다해서 비밀키를 아는 게 어렵다. 암호화 자체는, 거듭제곱과 나머지 연산만으로 암호화가 가능하다. 
- 이는 소수 덕분에 가능하다. 소수 p, q를 곱하면 합성수 n이 나오는데, n의 인수는 p와 q 뿐이다. 합성수에서 소수를 알아내기란 몹시 어렵다. 
- 키 길이가 길어질수록 더 깨기 어려우므로, 컴퓨터 속도가 더 빨라지면 비트 수를 늘리면 된다. 
- 비밀키는 아주 큰 소수 p, q
- 공개 키는 합성수 n
- p, q와 특수한, 서로 간 특수한 관계인 e, d를 찾음. e는 공개 키의 두번째 요소가 되고 d도 비밀키의 두번째 요소가 된다. 
- 원문의 e의 d승 합성수 나머지 연산은 원문에 합성수 나머지 연산의 곱과 같다. 
- d*e의 합성수 람다 나머지연산은 1과 같다. 

### RSA 키 생성
1. 매우 큰 두 소수를 찾고 
2. 그 둘을 곱해 n 
3. e찾고 d 찾는다. e는 n의 카마이클 수와 서로소인 값. 

### RSA 증명
원문을 e 거듭제곱 후 n으로 나눈 나머지가 c다. 그렇다면, d를 좌항 우항에 동시에 거듭제곱해도 값은 같다. 
복호화 공식은 c를 d 제곱 후 n으로 나눈 나머지가 원문!

이런 증명에 사용된 법칙이 정수론에 속한다. 

## 비대칭키 암호화와 대칭키 암호화
숫자가 크기 때문에 비대칭키 암호화가 더 느리다. (보통)
그리고 알고리듬 자체도 복잡하다. 결국 하나의 키를 공개하기 때문이다. 

그래서 비대칭과 대칭 키 암호화를 같이 사용하기도 한다. 예를 들자면, 세션 동안 사용할 대칭 키를 비대칭 키 암호화를 이용해 전송.

