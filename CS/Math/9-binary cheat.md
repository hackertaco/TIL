XOR의 속성을 이용하면 0으로 초기화가 가능하다. 
a = a^a이 a=0보다 성능이 빠르다. 아직도 똑똑한 컴파일러는 XOR 연산으로 바꿔주기도 한다.
특별한 하드웨어 작업에서는 볼 수 있다.

XOR을 세번 이용하면, 두 수의 값을 바꿀 수 있다.

### 비트 마스킹
if((num&0x1)== 0) // 짝수

if((num&0x1)!= 0) // 홀수

필요한 비트만 추출하는 방식이라 비트 마스킹이라고 한다. 
여기서 마스크란, 비트 필드에 대한 비트연산을 할 때 사용하는 데이터다. 

### 특정 플래그를 켜는 방법
> 플래그 = 플래그 | 마스크;
- 일단 마스크를 만든다. 켜고 싶은 비트를 1, 나머지는 0으로!
- 플래그 변수와 OR 연산을 수행한다.

### 특정 플래그를 끄는 방법?
> 플래그 = 플래그 & ~마스크
- 일단 마스크를 만든다. 끄고 싶은 비트를 1, 나머지는 0으로 만든 후 NOT 연산을 한다.
- 플래그 변수와 AND 연산을 수행한다.

### 특정 플래그를 토글하는 법
> 플래그 = 플래그 ^ 마스크
- 일단 마스크를 만든다. 
- 플래그 변수와 XOR 연산을 수행한다.

값 전체를 비교하는 데 사용하게 된다.

여기에서 조금 더 데이터 패킹으로 확장해볼 수 있다.
사용하는 용량을 줄이기 위하여, 혹은 다양한 데이터를 하나의 자료형에도 저장할 수 있게끔 한다. 단지 bool형이 아니더라도.
정렬 속도를 높이기 위해서도 사용한다.

-> 정수 값으로 비교해서 순서를 바꾸고 반환할 수 있기 때문이다.

### 비트 마스킹: 대소문자 변환
A와 a의 askii 코드 차이는 32다. 즉, 2의 5승
2의 5승 자리가 0인지 1인지에 따라서 대소문자가 달라진다. 
대소문자임을 알고있다면, 대소문자 자리를 XOR를 통해서 서로 변환할 수 있고 (16진수 0x20 이용)
모른다면, | 혹은 &~를 사용한다.

### 비트 마스킹: 2의 승수 판별하기
1이 한개만 있으면 2의 승수.
어떤 수를 계속 2를 곱한 것도 2의 승수다.

2로 계속 나누어 2의 승수임을 확인하기도 한다.
그런데 이는 비트 수만큼 반복을 도는 것이다. 

더 나은 방법은 해당 수에 1을 빼서, 원본과 and 연산을 하는 것이다. 