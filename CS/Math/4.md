## 실수 = 유리수 + 무리수

## 정수의 이진법 표기
계속 양쪽에 2를 곱해서 2진법으로 실수를 표기하게끔 처리

그러나, 계속 무한 반복될 수 있다.
정확히 2진수로 표현 못하는 실수가 있는 것이다. 

이를 극복할 두 가지 방법
- 고정 소수점 수
- 부동 소수점 수

## 고정 소수점 수
정수 표현을 실수에 적용(확장)
몇자리까지는 정수로, 그 아래에는 소수로 표현. 
ex. 4비트는 정수 3비트는 소수면
Q4.3으로 표현

- 이는 표현할 수 있는 범위의 값은 확실히 표현 가능.
- CPU에서 실수 계산을 해주는 전담 장치가 없었기에 이를 직접 구현해서 쓰는 경우가 많았다.
- 오차가 없어야할 경우 적합.

단점은,
- 표현 가능한 수의 범위가 작아진다.
- CPU가 고정 소수점 수를 지원하지않는다.

- 연산 뒤 정밀도 손실, 오버플로 발생 가능.


## 부동 소수점 수
이걸 잘 알아야한다.
floating-point number

어디든 소수점이 이동한다.
실제 유효한 숫자는 같으나, 소수점을 움직이는 것으로 표현 가능한 범위가 엄청 늘어난다.
그래서 정밀도를 희생한다.

### 장점
- 표현 가능한 범위가 넓다
- CPU에서 표준을 다 지원

### 단점
- 돈 관련 프로그램에 쓰기 부적합.
- 그러나 대부분의 경우에는 적합

### 어떻게 구현되어있는지?
그 전에, 과학적 표기법을 알아야한다.
너무 크거나 작을 때, 가수와 지수로 n승을 만들어 정리.
ex. 4 * 10^19

- 유효 숫자란: significant digits -> 수 정확도, 정밀도에 영향을 주는 숫자 

### 정확도와 정밀도
같은 행위를 동일한 횟수로 반복해서 얻은 데이터의 패턴을 설명한다. 
- 정확도
  - 참 값에 얼마나 근접했는가
- 정밀도
  - 데이터들이 얼마나 밀접해있는가.

### 정규화한 과학적 표기법
정규화? 다양한 스케일의 값을 동일한 스케일, 동일한 규격으로 맞게 맞추는 것

- 가수의 제일 왼쪽에 있는 유효숫자를 정수부의 첫번째 자리로 이동
  - 3234553* 10^2를 3.234553 * 10^8로 표현하는 것
- 