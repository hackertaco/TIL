## 실수 = 유리수 + 무리수

## 정수의 이진법 표기
계속 양쪽에 2를 곱해서 2진법으로 실수를 표기하게끔 처리

그러나, 계속 무한 반복될 수 있다.
정확히 2진수로 표현 못하는 실수가 있는 것이다. 

이를 극복할 두 가지 방법
- 고정 소수점 수
- 부동 소수점 수

## 고정 소수점 수
정수 표현을 실수에 적용(확장)
몇자리까지는 정수로, 그 아래에는 소수로 표현. 
ex. 4비트는 정수 3비트는 소수면
Q4.3으로 표현

- 이는 표현할 수 있는 범위의 값은 확실히 표현 가능.
- CPU에서 실수 계산을 해주는 전담 장치가 없었기에 이를 직접 구현해서 쓰는 경우가 많았다.
- 오차가 없어야할 경우 적합.

단점은,
- 표현 가능한 수의 범위가 작아진다.
- CPU가 고정 소수점 수를 지원하지않는다.

- 연산 뒤 정밀도 손실, 오버플로 발생 가능.


## 부동 소수점 수
이걸 잘 알아야한다.
floating-point number

어디든 소수점이 이동한다.
실제 유효한 숫자는 같으나, 소수점을 움직이는 것으로 표현 가능한 범위가 엄청 늘어난다.
그래서 정밀도를 희생한다.

### 장점
- 표현 가능한 범위가 넓다
- CPU에서 표준을 다 지원

### 단점
- 돈 관련 프로그램에 쓰기 부적합.
- 그러나 대부분의 경우에는 적합

### 어떻게 구현되어있는지?
그 전에, 과학적 표기법을 알아야한다.
너무 크거나 작을 때, 가수와 지수로 n승을 만들어 정리.
ex. 4 * 10^19

- 유효 숫자란: significant digits -> 수 정확도, 정밀도에 영향을 주는 숫자 

### 정확도와 정밀도
같은 행위를 동일한 횟수로 반복해서 얻은 데이터의 패턴을 설명한다. 
- 정확도
  - 참 값에 얼마나 근접했는가
- 정밀도
  - 데이터들이 얼마나 밀접해있는가.

### 정규화한 과학적 표기법
정규화? 다양한 스케일의 값을 동일한 스케일, 동일한 규격으로 맞게 맞추는 것

- 가수의 제일 왼쪽에 있는 유효숫자를 정수부의 첫번째 자리로 이동
  - 3234553* 10^2를 3.234553 * 10^8로 표현하는 것

### 32비트 부동 소수점(IEEE 754)
- 부호 비트: 1비트, 0이면 양수, 1이면 음수
- 지수비트: 8비트. 음/양수 표현 가능. 실제 나온 값에서 -127을 해야한다.
  - 그 이유는 음수 표현을 위하여.
- 가수비트: 23비트
  - 가수의 정수부는 언제나 1이고, 가수비트는 소수점부터. 
  - 1.b22b21b20 * 2^e...b: 가수, e: 지수

### 지수는 -126에서 125까지의 값을 가진다.
모든 비트가 0이거나 1일 때 예외 상황이 발생하기 때문
0에 가까운 수를 표현하기위해, 혹은 무한대의 수를 표현하고자 해서.


비트패턴이 다 0이면 최종 0을 만들수있다.
- 비정규화 수 
  - 정규화 안된 수. 지수비트가 0이지만, 가수비트가 0이 아닐 때 절대값이 엄청 작은 숫자를 표현하기위해 사용
  - 지수비트가 0xff + 가수비트 0x00
    - 무한대

### 32비트 부동 소수점의 예
1. 3.75
- 10 -> 2진수 변환 (11.11이 되는데)
- 이를 정규화하면 1.1111 * 2^1

- 이를 다시 10진수로 돌리면
- 지수는 128 - 127
- 가수는 

2. 3.14
- 10 -> 2진수 변환
- 유실되는 데이터가 있다.
- 다시 10진수로 돌아오면 더 큰 수가 등장한다.

- 실수는 무한대지만 갯수가 정해진 비트로 표현하다보니 근사치로 나올 수밖에 없다.

### 부동 소수점의 정밀도
6-9자리의 유효숫자를 보장한다. 
어떤 경우에는 6자리, 어떤 경우에는 9자리 보장
숫자 자체를 반올림해서 자릿수를 맞추어야한다.

정밀도 6: 10진수 실수 float에 저장했다가, 다시 그걸 10진수 실수로 변환한 뒤, 원래 10진수 수의 자리를 6자리로 맞추면 다시 그 수가 나온다.

### 정밀도의 중요성
- 돈 관련 업계에서 float은 좋지않다.
- 