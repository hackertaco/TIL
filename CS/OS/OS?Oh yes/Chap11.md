파일 시스템은 대부분 디스크에 저장되고, 파일시스템에 대한 요청은 디스크 시스템에의 접근을 필요로 한다. 

그래서 디스크 시스템의 성능을 향상시키고 결과적으로 성능을 향상시키기 위해서는 스케줄링이 필요하다.

## 디스크의 구조
디스크 시스템 = 데이터 저장하는 디스크 팩 + 저장된 데이터를 읽어내는데 동원되는 디스크 드라이브

### 디스크 팩
- 전원이 끊겨도 데이터를 보존할 수 있는 저장 매체
- 여러 장의 원판 디스크로 이루어져있다.
- 회전축에 의한 회전동작 + 붐에 의한 전후 동작 -> 헤드를 위치시키고 읽기나 쓰기가 이루어진다.

- 디스크의 한 면을 보면 여러개의 트랙으로 구성이된다.
  - 한 트랙은 여러 개의 섹터로 이루어진다. -> 섹터 단위로 디스크에 쓰이거나 읽힌다. 보통 이를 블록이라고도 부른다. (-> 섹터의 크기 또는 섹터 크기의 정수배)
  - 트랙 사이의 갭: 트랙 구분 위해 
  - 섹터 사이의 갭은 데이터의 정상적인 읽기 쓰기를 위한 여유공간
  - 섹터가 모여 트랙 트랙이 모여 디스크 한 면 한면들이 모여 디스크 팩이된다. 

- 암의 길이는 같아서, 헤드는 각 면의 같은 트랙에 위치한다. 
  - 트랙마다 헤드가 있는 경우를 고정 헤더
  - 트랙을 옮겨 다니면서 읽기 쓰기를 하는 경우를 이동 헤드
- 디스크 팩에서 모든 트랙을 묶어 실린더라고 부른다.
  - 디스크에 큰 용량의 데이터를 순차로 저장할 때 실린더 단위로 저장한다. 

- 특정 섹터에 대한 주소지정은 실린더 (혹은 트랙)번호, 표면번호, 섹터 번호 순으로 이루어진다. 
  - 이런 물리적 주소는 사용하기 복잡한 측면이 있어서,  논리적인 상대 주소를 사용하기도 한다. 
  - 디스크 시스템의 데이터 전체를 블록들의 나열로 보고, 각 블록에 대해 번호를 부여하여 임의의 블록에 접근할 수 있게 하는 것

- 주소가 주어지면, 실린더 번호를 보고 헤드를 해당 트랙으로 이동시켜야 하는데, 이때 소요되는 시간이 **탐색시간**이다.
- 지정된 섹터가 회전하여 헤드 밑으로 오는 데 걸리는 시간을 **회전 지연 시간**
- 섹터가 헤드 밑을 회전하는 동안 읽거나 쓰게 되는 시간을 **전송시간**이라 한다. 

디스크에서의 접근 시간 = 탐색 시간 + 회전 지연 시간 + 전송 시간

- 탐색 시간은 접근 시간에서 제일 큰 비중을 차지한다. 어떻게 처리하는 데 따라 성능을 높일 수가 있다. 
  - 입출력 요청들에 대한 탐색을 어떤 순서로 처리할 것인가가 디스크 스케줄링

- 디스크 스케줄링 기법의 평가 기준: 
  - 단위 시간당 처리량
  - 평균 응답 시간
  - 응답 시간의 예측성: 디스크 입출력 요구를 보낸 쪽에서 자신의 요청에 대한 서비스가 언제 끝날지를 추측할 수 있는가에 대한 지표. 응답 시간의 분산이 작으면 예측성이 좋고, 크면 예측성이 좋지않다. 

## 디스크 스케줄링
디스크는 근본적으로 기계적 속도에 달렸다.

### FCFS
디스크 입출력 요청들을 도착한 순서대로 서비스
- 입출력 부하가 작을 경우에 적합

### SSTF(Shortest Seek Time First)
- 현재 큐에 도착해 있는 요구들 중 현재 헤드의 위치로부터 가장 가까운 요구를 먼저 서비스 
- 단위 시간당 처리량은 극대화, 부하가 크지 않은 경우 평균 응답 시간도 낮게 유지 가능.
- 그러나, 응답 시간의 예측성은 낮다. 
- 따라서 대화형 시스템에 부적합

### SCAN 스케줄링
- 현재 헤드의 위치와 가장 가가운 위치에 대한 요구를 먼저 서비스하지만, 현재 헤드의 진행 방향으로만 입출력 요구를 처리
- 마지막 실린더, 양 끝의 실린더에 도착했을 때에만 방향을 전환
- 단위 시간당 처리량, 평균 응답 시간의 면에서 만족할만한 성능

### LOOK 스케줄링
- 헤드가 진행하는 도중 진행 방향의 앞쪽으로 더 이상의 요구가 없으면 양끝의 실린더까지 진행하지 않고 그 자리에서 방향을 바꾼다. 
- 이것과 SCAN은 응답 시간의 예측성 측면에서 우수
- SCAN처럼 굳이 끝까지 갈 필요가 없다. 
- 그러나, 이 둘 모두 반대 방향의 요구들의 대기시간이 계속 길어지게 될 수 있다.

### N-step SCAN
- 방향을 바꾸는 시점에서 큐에 대기 중인 요구들만을 대상으로 한다.
- 무기한 연기의 가능성은 완전히 사라진다.

### C-SCAN
- 한 방향으로만 서비스를 진행
- 양 끝 부분의 트랙과 중앙 부분 트랙을 균등하게 서비스
- 응답 시간의 편차를 극소화

### Eschenbach
- 헤드가 진행하는 과정에서, 각 실린더에 대해 디스크팩의 한 번 회전시간 동안만 입출력 요구들을 처리하는 기법
- 서비스를 받지 못하는 요구들에 대한 처리는 다음으로 미룬다.
- 탐색 시간의 최적화
- 회전지연시간의 최적화

보통은 C-SCAN, SCAN스케줄링 기법이 많이 사용된다.

## 회전 지연 시간의 최적화
탐색 시간을 필요로 하지않는 고정 헤드 디스크 시스템이나, 
트랙마다 헤드를 갖는 드럼 등의 보조기억 장치에서 사용된다. 
- 섹터 큐잉이라는 기법 사용 = SLTF 
  - 각 섹터별로 별도의 큐를 두어 관리 
  - 거의 최적에 가깝다. 

## 디스크 관리를 위해
디스크 시스템의 성능 증대를 위해
### 버퍼링 기법
- 디스크에서 자주 참조되는 데이터를 커널의 버퍼에 저장해 관리한다. 
  - 데이터의 일치성 문제 고려 필요
  - 프로세스의 데이터 참조 패턴에 지역성이 없는 경우 주기억 장치 공간에 적재돼있을 확률이 매우 낮을 수 있으므로 큰 효과가 없을 수도 있다. 

### 디스크 스트라이핑
- 디스크 인터리빙이라고도 한다. 
- 여러 개의 디스크 시스템을 묶어서 논리적으로 하나의 디스크 시스템의 역할을 하게 한다. 
- 이에 저장될 데이터는 스트립이라는 작은 단위로 나뉘어진다. 
- 순차적으로 저장되도록 한다. 
- 한 블록에 저장될 데이터를 여러개의 서브블록으로 나누어 디스크 시스템에 하나씩 배치시킨다. 
- 병렬로 접근. 

### RAID 구조
- RAID-0: 디스크 스트라이핑 시스템. 낮은 비용 높은 성능. 데이터 중복 없어서 신뢰성 고려하지않음.
- RAID-1: 0에 미러링 개념 추가. 데이터 블록 중복. 하나가 고장나도 블록 유지. 신뢰성 높고 가용성 높다. 그러나 비싸다. 
- RAID-0+1: 0과 1 조합. 둘의 장점 함께 취함
- RAID-2: 섹터 스트라이핑. 해밍 코드 사용한 ECC 정보 별도 저장. 최근은 내부적으로 그 정보를 갖도록 되어있어 잘 사용되지않음
- RAID-3: 한 디스크가 패리티 정보 저장. 훼손된 스트립 복구 가능해서 중복 효과. 접근 속도 증가시키나 여러 입출력 요구들을 동시에 처리하는 능력은 없다.
- RAID-4: 한 디스크 내에 블록들의 패리티 정보를 저장. 병목현상이 나타난다.
- RAID-5: 회전 패리티 배열. 디스크를 하나로 고정하지 않는다.
- RAID-6: 두개의 다른 패리티 계산 수행. 높은 가용성. 두 개의 패리티 블록에 매번 반영