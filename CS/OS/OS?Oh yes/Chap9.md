가상 메모리는, 프로그램의 일부분이 메모리에 올라오게 해서, 보다 많은 개수의 프로세스, 보다 큰 프로그램을 실행하게 해준다. 

다만, 이는 좀 더 빠르게 매핑을 하고, 관리를 잘해야한다. 이 가상메모리의 장점을 살리기 위한 방법 여러개가 있다.

## 하드웨어의 사용
매핑 시간 최소화를 위하여, 추가로 하드웨어를 이용한다.
- TLB
- 페이지 테이블을 캐시에 하기
- 다수의 레지스터 사용
- 참조 비트, 갱신 비트 등..

## 관리를 위한 다양한 기법들

### 적재 정책
언제 메모리를 적재할지에 대한 것
- 요구 적재: 적재 요구가 있을 때 (매핑할 페이지 정해지고, 이 페이지가 메모리에 없어 디스크로부터 적재해 와야할 때)
  - 문맥 교환과 디스크 입출력 부담
- 예측 적재: 확률적으로 참조될 가능성이 높은 페이지를 미리 적재. 예측이 잘못되면 메모리 낭비. 

### 배치 정책
어디에 메모리를 적재할 것인지
- 페이징은 메모리의 프레임과 크기가 같아서 문제가 없지만, 
- 세그먼테이션은 다 달라서 이를 수용할 배치 정책이 필요하다.

### 할당 정책과 교체 범위
프로세스에 메모리를 얼마나 줄지를 결정
- 시스템에서 정해놓은 개수를 쓰게 하고, 그 변동이 없도록 하는 것은 고정할당 == 전역 교체를 하지 않는다. 변동이 없어야하기 때문이다. 
- 실행 도중 프로세스에 부여된 프레임 수가 변하면 가변할당
교체 정책과 밀접한 연관.

### 교체 정책
메모리가 꽉 찼을 때 적재될 페이지를 위해 프레임을 어떤 페이지가 비워줄지에 대한 결정 정책
#### 최적 기법
교체할 때 최선은, 페이지 부재를 최소화하는 것이다.
현 시점에서 앞으로 가장 오랫동안 참조되지 않을 페이지 = 미래에 참조될 때까지의 시간이 가장 긴 페이지를 찾아 교체하는 것.

그러나 현실적으로 불가능. 프로세스들이 앞으로 어떤 페이지를 참조할 지 모르기 때문이다.

#### FIFO
적재된지 가장 오래된 페이지 교체. 
타임스탬프를 붙이거나 (추가 기억장소 필요) 큐를 이용 (관리, 유지 비용, 자리 잡는데 걸리는 오버헤드)
- 최적에 비해 성능 저조
- 순수한 fifo만으로는 교체 정책에 어려움
- 프레임을 더 주어도 더 많은 부재 발생하는 경우도

#### LRU (Least Recently Used)
가장 참조된지 오래된 것들부터 교체.
스택 이용.
FIFO와 동일하게 타임스탬프, 따라서 오버헤드는 발생할 수 있다. 

이는 미래를 알 수는 없지만, 최근에 참조된 것이 앞으로도 당분간 자주 참조될 것이라는 판단

#### Second-chance (clock)
- FIFO의 변형.
- 적재된 후 한번이라도 더 참조된 페이지에 참조 비트를 두어서, 자신이 교체되어야 할 때 해당 비트가 0일 시 교체되고, 1일 시 한번 더 기회를 주어 참조 비트를 0으로 만들고 제일 큐 제일 끝으로 간다.
  - 교체 포인터는 해당 프레임 뒤에 있던 다른 프레임이다.
  - fifo 큐를 이용할 때도 있지만, 순환 큐를 사용해 시계방향으로 표현하기도 한다. 

#### 개선된 Second-chance
clock 기법에 갱신 비트 추가. 페이지가 적재 중 변경되었다는 뜻.
교체가 되면 디스크에 기록을 해주어야 하기 때문에, 가급적 교체를 미룬다. 
참조 비트와 함께 쓰여 총 4가지 경우가 있다.
1) 참조 갱신 둘다 0
   - 현재 포인터 위치에서 포인터 이동. 모두 0인 것 찾아 교체
2) 참조 0 갱신 1
   - 1을 찾지 못했을 때, 포인터를 이동하면서 모든 프레임의 참조비트를 0으로 바꾸고, 이 단계에서도 해당 페이지 찾지 못했을시 다시 처음으로 돌아와보면, 참조는 0이 되어있을 것이므로, 
   - 그 단계에서도 못 찾으면 
   - 참조 0 갱신 1을 찾아 교체한다.
3) 참조 1 갱신 0
4) 참조 1 갱신 1

#### LFU(Least Frequently Used), MFU(Most Frequently Used)
둘 다 편향된 시각에 근거. 적재돼있는 동안 참조된 횟수 누적하여 기록, 그 값으로 교체 대상을 파악한다.
LFU는 가장 적은 것(앞으로도 참조는 없겠지~), MFU는 가장 많은 것(충분히 참조되었겠지~)

별로 안 쓰인다.

#### 페이지 버퍼링
- 단순한 교체기법과 함께 사용
- 적재 가능한 가용 프레임 몇개를 풀로 유지한다. 
  - 부재가 생기면, 적재될 페이지 -> 풀로 이동
  - 교체될 페이지 -> 적재 중 변경된 경우에 한해 디스크로 쓰여지고 풀에 보태진다.
    - 교체될 페이지들을 가능한 메모리에 남겨 디스크 입출력 횟수를 줄이고, 재참조될 경우 바로 사용 가능. 
    - 시간적 순서를 지키지않아도 되어서 빠른 응답 기대
  - 변경된 페이지들을 변경 리스트에 유지하다가, 디스크 작업이 여유가 있을 때 한꺼번에 쓴 다음 이 페이지들의 갱신비트를 0으로 해주어서 페이지들이 실제로 교체될 때, 응답 시간 줄일 것이다.

### Working set 이론, PFF
#### Working set 이론
- 지역성 고려. 가변 할당 기반. 
- working set: 프로세스가 특정 시점에서 집중적으로 참조하는 페이지 집합. 현 시점에서의 지역성을 표현
- 윈도우 크기(일정 크기의 시간. 이 이론에서는 현 시점에서 과거의 몇 개의 참조 단위)를 정하는 것은 중요. 너무 크면 메모리 낭비. 너무 작으면 스레싱
- working set이 작아지면 프로엠 회수, 커지면 할당.
- 그러나 지역성이 변화하는 구간이 발생하는 등 그 시점의 지역성을 잘 표현하지는 못한다. 
- 정확한 working set을 추정하거나 최적의 윈도 크기 정하는 게 어렵다.
- 매 페이지 참조할 때마다 working set 조정 오버헤드도 있다.
#### PFF
- 최적의 윈도 크기를 정하고자, working set을 페이지 부재의 간격으로 결정.
- 부재가 발생했을 때, 해당 부재와 이전 부재 사이의 간격이 기준치보다 크면 프레임이 과도히 설정되었으므로 줄이고
- 작으면 늘려준다. 
- 정교한 잣대를 추가해주고, working set 조정 횟수가 줄어 오버헤드가 적다.

### 클리닝 정책과 부하조절
#### 클리닝 정책
적재 중에 페이지 내용이 변경되었다면? 그 변화를 디스크에 언제 기록할지에 대한 정책
- 요구 클리닝 : 교체 대상으로 정해졌을 때 기록, 입출력은 최소화 하지만 시간적인 절차를 따라야한다. 페이지가 대기해야한다. 그래서 응답성이 떨어진다.
- 예측 클리닝 : 기록 후에도 메모리에 남아있고, 이 이상으로 변경이 없다면 교체 시에 빠른 응답을 기대할 수 있지만, 만약 또 변경되었다면 입출력이 추가로 발생한다.

- 클리닝 정책은 페이지 버퍼링과 사용되면 좋다
- 대부분은 요구 클리닝 사용

#### 부하 조절
다중 프로그래밍의 정도를 조절하는 것이다. 너무 높으면 스래싱. 너무 낮으면 시스템 자원을 제대로 쓰지 못하는 것.

- Working set이론과 밀접한 연관

여러 법칙이 있다. 
1) L=s법칙: 부재 간격의 평균값과 부재 처리 시간 평균값 같도록 하면 CPU 활용도 최대로
2) 50%법칙: 페이징 장치의 활용을 50%로 하면 CPU 활용 최대로

## 몇가지 고려사항
### 페이지의 크기
크기를 작게 하면
- 페이지 개수 증가 -> 엔트리 개수 증가 -> 페이지 테이블 크기 증가 -> 메모리 적재 부담
- 프레임 크기 작아져서 이를 관리할 커널 부담 증가
- 페이지 개수 증가 -> 적재와 교체 횟수 증가 -> 잦은 입출력. 하지만 전송 시간은 줄 것
- 불필요한 내용 빼고 꼭 필요한 내용만 담은 페이지만 working set에 추가
- 마지막 페이지의 반은 내부 단편화. 페이지가 작으면 단편화 크기가 준다.

### 프로그램의 구조
- 실행될 프로그램을 메모리의 특성에 맞춰 잘 작성하면 더 나은 성능이 나온다

### 프레임 잠금
- 커널과같은 프레임, 부재 처리 루틴 프레임은 교체되면 안되어 잠금설정을 해야한다.

