프로그램의 실행을 위하여 메모리에 프로그램을 적재해야한다. 따라서 메모리의 관리는 중요한 부분이다. 

메모리의 관리에는 메모리를 어떻게 구성할지부터 시작한다.
## 메모리 구성
구성이 정해지면 맞는 관리 방법도 생각해볼 수 있다. 
1. 다중 프로그래밍의 정도 -메모리에 있는 프로세스의 수
2. 메모리의 분할 방식 - 프로세스에 부여되는 메모리의 양을 같거나 다르게할 수 있다. 정적, 동적
3. 메모리의 할당을 연속적으로 할지, 비연속적으로 할지

## 메모리 관리
메모리 구성이 주어지면, 이에 맞게 효율적인 관리를 하고자 한다.
- 적재 기법
  - <언제> 메모리를 할당할지를 다룬다. 
  - 요구가 있을 때 적재하는 요구 적재. 보통 이를 사용
  - 예상하고 미리 적재하는 예상 적재가 있다. 
- 배치 기법
  - <어디에> 메모리를 적재할지를 다룬다.
  - 고정 분할의 경우, 했던 부분을 다시할지 아닐지를 결정
  - 가변 분할의 경우, 몇 가지 적합 기법이 있다.
- 교체 기법
  - 메모리 공간이 부족할 때, 이미 메모리에 있는 프로세스 중 어떤 것을 골라 디스크로 내보내고 공간을 확보할지
- 할당 기법
  - 프로세스에 메모리 공간을 얼마 정도로 줄 것인가를 결정

## 단일 프로그래밍
한 번에 하나의 프로세스만이 적재되고, 실행이 종료되면, 다음 프로세스 실행.
근데 이 경우 몇 가지 문제를 해결해야한다. 
1. 
   - 메모리의 크기 >= 프로그램의 크기 : 문제 없다.
   - 메모리의 크기 < 프로그램의 크기 : 프로그램의 일부를 먼저 적재하고, 나머지 부분들을 다시 적재해야하는 오버레이 방식 사용
     - 이 오버레이는 프로그램을 적당한 크기로 나눠야한다. 그래서 수동적 오버레이라 부른다.

2. 
보호 기법 요구 -> 프로그램의 실행 중 커널 영역 침범하지 못한다. 경계 주소 값을 넣어둔다. 


## 고정 분할에서의 다중 프로그래밍
- 관리가 쉬우나, 다양한 상황에 유연하게 대처하지 못한다.
- 동일한 분할 크기 = 같은 크기의 메모리
  - 다양한 크기로 분할하면 유연하지만 복잡도는 커진다.
- 프로그래밍 컴파일 시 주소지정이 된다면 -> 메모리의 할당은 절대로더에 의해 항상 지정된 분할로 들어가게 될 것이다.
  - 이는 비어있으나 활용되지 못하는 분할의 낭비가 일어날 수 있어, 재배치가 필요하다.
- 가장 큰 분할보다 더 큰 프로그램의 수용문제 -> 오버레이로 해결할 수밖에 없다.
- 메모리 보호: 사용자 간의 경계를 설정.
- 메모리 공간의 단편화: 고정되어있는 메모리 탓에, 수용하고 나면 메모리가 낭비된다. 
  - 내부 단편화: 분할 내의 낭비공간
  - 외부 단편화: 너무 커서 들어가지 못하는 프로세스에 낭비되는 메모리 분할 크기

## 가변 분할에서의 다중 프로그래밍
분할의 시기나 개수 크기가 정해진 것이 없고, 그 크기만큼 프로세스 수용 시 할당한다.
다중 프로그래밍의 정도를 조절 가능하다. 
메모리에서 사용 중인 공간과 빈 공간들에 대한 정보가 필요하다.

- 최초 적합: free 리스트의 첫 노드부터 시작. 제일 처음 발견되는 노드에 할당
- 최적 적합: free 리스트 끝까지 탐색. 제일 차이가 안 나는 노드 할당
- 최악 적합: free 리스트 끝까지 탐색. 제일 차이가 많이 나는 노드 할당

최적 적합의 결과로 남는 크기는 작아서, 실제로 활용되지 못하는 단점을 가진다. 이 공간을 홀이라고 하며, 외부 단편화의 대표적 예다.
이를 역발상으로 해결하고자 하는 것이 최악 적합.
- 최초와 최적이 최악에 비해 효율적이며, 대부분의 경우 최초가 실행 속도가 빨라 최초적합을 사용하면 된다.
  - 그러나, 시간이 지날수록 free 리스트의 앞부분부터 작은 노드들이 등장(홀), 탐색 시간이 점점 길어진다. 
  - 그래서 이를 순환 구조로 하고, 할당이 될때마다 ㅡ헤더포인터를 이 노드 다음으로 옮기게 하는 next-fit이라는 방법이 있다.

그럼에도 불구하고 결국에는 홀이 될 것이며, 이 빈 공간을 합쳐 더 큰 빈공간을 만들어야한다.

이것에는 두 가지 방법이 있다.
1. 인접한 빈 공간의 병합
   - 빈 공간으로 프로세스가 메모리를 반납할 때마다 인접한 (위아래) 공간을 합친다.
2. 빈 공간 전부의 통합
   - 사용 중인 공간을 메모리의 한쪽 편으로 밀착시켜 옮기고, 빈 공간들은 전부 합친다. 
   - 병합과는 달리 사용 중인 공간의 위치 이동이 발생한다. 
     - 상당한 시간 소요
     - 프로세스 실행 중지 -> 자원 상당수 낭비
3. 버디 시스템
   - 메모리가 사전에 분할되어있지는 않고, 가변 분할처럼 크게 되어있다.
   - 그 와중에 프로세스의 요청이 들어올 때, 그 프로세스 크기보다는 크지만 차이가 가장 적은 2의 승수 크기로 해당 프로세스를 집어넣는다. 이때는 물론 내부 단편화가 발생할 수 있다. 
   - 같은 크기로 분할된 인접 공간을 버디라고 부른다. 
   - 반납될 때는 이 버디가 사용되지 않고있다면, 합쳐진다. 
   - 고정과 가변의 절충. 병렬 프로그래밍에 활용 가능.