시스템의 데이터는 운영체제에 의해 관리되고, 이 데이터의 논리적 단위는 파일이다.
이들의 저장, 관리를 위해 시스템 유틸리티 프로그램이 동원되는데 이것을 파일 시스템이라 한다.

## 파일에 대해
- 저장 장치에 연관된 정보의 논리적 저장 단위. 
- 물리적으로는 바이트의 나열

- 장기적 보관 가능
- 공유 가능
- 다양한 응용에 맞게 내부구조를 가진다.

단일 값을 가지는, 데이터의 기본 요소 -> 필드
그 필드가 모여 레코드가 되고
이 레코드들이 모여 파일이 된다. 
 
### 파일에 대한 접근방법
- 더미 파일
  - 생성되는 순으로 추가
  - 일련의 연속적인 필드
  - 일정한 구조 없음
  - 사용하는 경우: 데이터를 일정한 형태로 구성이 어렵거나, 저장될 데이터의 크기 구조가 다를 때.
  - 전체 레코드 검색에서는 용이하지만, 대부분은 적합하지않다.

- 순차 파일
  - 가장 일반적 형태. 같은 크기 레코드들로 구성. 같은 개수와 크기의 필드로 구성
  - 일괄처리에 적합. 하지만 대화형 접근에서는 순차적으로 접근해나가야해서 효과적이지 않다. 
  - 테이프와 같은 저장 장치에 잘 맞다(순서대로 접근하기 때문에)

- 인덱스 순차 파일
  - 순차 파일의 특성에 임의의 레코드를 빨리 접근하기위해 파일 인덱스, 레코드의 추가를 위한 오버플로우 파일을 추가했다. 
  - 순차 파일의 장점을 살리고, 특정 필드 하나를 키 필드로 한 인덱스 사용. 
  - 추가되는 레코드는 오버플로우 파일에 모았다가, 적정 시기에 원래의 순차 파일과 합병한다.

- 인덱스 파일
  - 특정 필드 하나만 키 필드인 인덱스 순차 파일과는 다르게, 모든 필드 혹은 몇개의 필드에 키를 만든다.
  - 일괄 처리 필요없고 빠른 접근을 할 때
  - 레코드들의 위치나 길이에도 제약이 없다. 

- 직접 (해시)파일
  - 특정 필드는 키 필드. 그러나 레코드들이 순차적으로 저장될 필요는 없다. 
  - 키 필드의 값은 해싱을 통해 임의 레코드에 접근하게 돕고
  - 빠른 접근이 요구되고, 한번에 한 레코드씩 접근할 때 유용

## 파일 시스템의 구조- 논리적 관점
논리적 구조 = 사용자에게 파일 시스템이 어떻게 보이는지에 대한 구조

1. 평면 디렉터리 구조
파일 시스템 전체에 한 개의 디렉터리 존재. 안의 파일은 서로 다른 이름을 가져야한다. (불편). 다중사용자일 때 더 불편
2. 2단계 디렉터리 구조
각 사용자당 하나의 디렉터리 구조. 다중 사용자 시스템에서의 파일명 부여 문제 해결. 그러나 더 이상의 하부 디렉터리를 가질 순 없다.
3. 계층(또는 트리) 디렉터리 구조
2단계에서도, 자신의 파일은 다른 이름을 가져야한다. 그래서 이를 계층 디렉터리 구조로 해결한다.
계층 구조에서는 루트 디렉터리가 있고, 그 아래에 여러 개의 디렉터리와 파일들이 계층적으로 있다. 
4. 비순환 그래프 
다수의 사용자들에 의해 공유될 필요가 있는 경우. 
계층구조의 확장. 계층 구조에서 링크라는 포인터를 사용해 임의의 디렉터리를 다른 디렉터리와 연결
5. 일반 그래프 디렉터리 구조
계층 구조에 링크를 추가하다보면, 탐색 시작 디렉터리로 다시 돌아오는 사이클이 발생 가능하다.
이 경우는 비순환 구조가 아니라, 일반 그래프가 되고, 파일 탐색이 무한 루프로 빠질 수도 있다. 

## 파일 시스템의 구조- 물리적 관점
물리적 관점 = 파일 할당, 빈 공간 관리
디스크는 블록들의 나열로 이루어져 있다. 파일들은 이런 블록 여러개를 동원하여 저장된다.
### 할당방식
1. 연속 할당
   - 연속된 다수개의 블록으로 파일 저장
   - 순차 처리에는 좋은 성능
   - 빈 공간활용 비효율적
   - 충분한 크기의 연속된 블록 찾기가 힘들게되어, 통합 작업 요구됨
2. 체인 할당
   - 비연속 할당. 
   - 파일의 내용은 블록 크기만큼 나눠져 체인을 따라 차례로 저장
   - 공간의 활용도 우수.
   - 그러나 몇개의 블록을 연속으로 처리할 때 블록이 흩어져잇어서 시간 지연

3. 인덱스 할당
  - 비연속 할당.
  - 가장 많이 사용.

이 할당 방법을 사용하려면 어떤 블록이 사용가능한지 알아야해서, 디스크 할당 테이블 자료구조로 관리된다.
### 빈 블록 확인 방식
1. 비트 벡터
  - 각 블록에 대해 사용 중이면 1, 비면 0으로 벡터를 둔다.
  - 파일 시스템에서 관리하고, 빠른 검색을 위해 메모리에 둔다
2. 리스트
   - 빈 블록을 리스트로 연결. 첫 블록 포인터는 커널이 가진다. 
   - 각 빈 블록은 다음 빈 블록에 대한 포인터나 블록 번호를 가지도록 한다. 
   - 많은 개수의 빈 블록을 할당해야하는 경우, 리스트 변경에 걸리는 시간이 파일의 생성을 느리게 한다.
3. 그룹화
   - 각 빈 블록은 n개의 빈 블록 번호를 가지고, n-1개는 빈 블록의 번호, 나머지 하나는 다음번 n개의 빈 블록 번호 가지는 블록번호다. 
   - 리스트를 사용하기는 하지만 연결되는 노드의 수가 1/n이다.
4. 인덱싱
   - 파일 할당에서의 인덱스 테이블을 통해, 디스크 상의 연속된 빈 블록들 당 하나의 인덱스 항목을 설정한다. 
   - 빈 공간 전체가 하나의 파일이며, 효과적으로 사용된다.

## 파일에 대한 접근 제어
= 곧 파일 보호한다는 뜻.

### 제어 기법들
1. 패스워드 
   - 파일마다 패스워드 부여. 
   - 그러나 파일마다이므로 불편
2. 접근 행렬
   - 개체 :파일
   - 접근 권한 : 읽기 쓰기 실행 첨부 등..
   - 도메인: 같은 접근 권한을 갖는 프로세스들의 집합
   - 행렬 내의 많은 부분들이 빈칸으로 표시될 가능성이 높다. (희소행렬)
   - 공간 낭비. 메모리 낭비
3. 전역 테이블
   - 시스템 전체에 대한 도메인, 파일, 접근 권한 을 세걔의 쌍으로 표현해서 전역 테이블에 저장하고 사용한다.
   - 그러나, 도메인이나 파일이 많아질 경우 테이블 크기가 커지고, 나열에 기반하여 비슷한 유형의 도메인이나 파일들을 묶어 그룹화하기 어렵다.
4. 접근 리스트
   - 파일에 대해 도메인 별로 접근 권한을 리스트의 형태로 나열. 
   - 파일 생성하면서 도메인별로 접근 권한 부여
   - UNIX가 이를 사용
   - 그러나 특정 도메인에 속한 프로세스들이 접근 가능한 파일들을 모두 찾아봐야할 경우에는 모든 파일에 대해 알아봐야해서 효율적이지 않다. (많이 발생하지 않는다)
5. 권한 리스트
   - 도메인 별로 그 도메인에 속한 프로세스들이 접근 가능한 파일과 접근 권한을 나타낸다.
   - 프로세스는 임의의 파일에 접근할 때, 시스템에 의해 권한 리스트가 검색되고, 접근이 허용된다.
   - 접근 리스트와 함께 다수의 시스템에서 활용
6. 락-키 방식
   - 파일은 락, 도메인은 키라고 불리는 비트 패턴의 리스트를 가지게 하고,
   - 임의의 도메인에 속하는 프로세스가 특정 파일에 접근할 때, 
   - 파일의 락들 중 하나와 도메인의 키들 중 하나가 반드시 일치돼야 접근을 허락하는 방식.

