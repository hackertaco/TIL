시스템은 사용자가 메모리 걱정을 할 필요없게끔, 주어진 메모리 크기 하에, 프로그램을 작은 조각으로 나눈다.
그 중 일부만을 메모리에 적재하되, 적재가 가능한 곳으로 흩어 넣어주게 된다. 

사실은 제한적인 크기이지만, 엄청 큰 메모리가 있는 것처럼 여겨져서 가상 메모리라고 부른다.

## 가상 메모리를 위해서
- 프로그램을 작은 조각으로 나눌 때, 그 조각이 다 일정한 크기라면 페이지, 아니라면 세그먼트라 한다. 
  - 이 모두는 메모리와 디스크 사이, 한번에 전송되는 전송 단위다. (블록이라 부른다.)
  - 가상 메모리 관리에서, 페이지로 나누면 페이징, 세그먼트로 나누면 세그먼테이션 시스템이라 부른다. 
- 주소의 매핑 개념이 가상 메모리 관리에서 제일 먼저 해결되어야 한다.
  - 실행 중인 프로그램이 참조하는 주소와 실제 메모리 상의 주소(실주소)가 달라서, 메모리 상의 주소로의 변환이 필요할 때 하는 것
    - 고정 분할의 경우는 참조 주소와 실주소가 동일해 사상이 필요없지만, 융통성이 없다.
    - 재배치의 경우에는 서로 달라 사상이 필요하지만, 프로그램이 조각나고 메모리 적재가 연속적이지 않으면 쓸모가 없다. 
  - 가상 메모리 관리에서는 프로그램 자체가 조각나고, 연속적으로도 저장되지않는다.
  - 실행 프로그램이 참조하는 주소(가상 주소)에는 프로그램 내에서의 순서, 그 조각 내에서의 위치를 알려준다. 이 값으로 명령어가 실행될 때, 사상 과정을 통해서 실 수조를 알게 된다. 

## 페이징
- 모든 프로세스들이 같은 크기의 조각들로 나뉘어야하는데, 그 한 조각을 페이지라 부른다. 메모리도 페이지와 같은 크기로 프레임이 나눠져있다. (일련의 번호가 매겨져있다.)
  - 페이지의 크기: 수 Kbyte, 2의 승수 배 크기 정도..
- 전체 페이지는 디스크에 저장. 몇 개만 비연속적으로 다른 프로세스들의 페이지와 섞여 적재. 이는 곧 매핑 단위가 된다.
- 운영체제는 가상주소를 실주소로 변환하기 위해, 프로세스 당 하나의 페이지 테이블이 있어야한다. 
  - 이 페이지 테이블은 페이지가 k개 있다면 k개의 엔트리를 가진다. (4바이트 크기)
    - 페이지의 일련 번호 순으로 엔트리를 배치한다.
  - 엔트리에 담긴 정보는 메모리에 적재여부(존재 비트, 1아니면 0), 적재된 경우 프레임 번호를, 0의 경우 페이지가 저장되어있는 디스크의 주소 필드를 나타낸다. 
- 페이지 테이블은 메모리의 커널 영역에 있다. 그리고, 실행 중인 프로세스의 페이지 테이블 시작 주소는 기준 레지스터에 들어있다. 
  - 기준 레지스터 값에 페이지 번호를 (사실은 페이지 번호 * 엔트리 크기) 더하고, 페이지 테이블에서 페이지의 사상정보 가진 엔트리를 찾은 후, 존재비트를 확인한다. 
    - 존재 비트가 1이면 프레임 번호를 알 수 있으므로, 이 프레임 번호에 페이지 크기를 곱하면 메모리에서 해당 프레임의 시작주소를 얻고, 여기에 d를 더하면 실주소로 접근이 가능하다. 
    - 존재 비트가 0이면 이를 메모리에 적재하기 위해, 엔트리의 존재비트를 1로 바꾸고, 적재된 프레임 번호를 기입한 후 매핑을 하면 실주소를 얻게 된다. 
- 페이지 테이블을 갱신 관리해야한다(운영체제가). 또 적재와 교체 등을 위해 메모리의 빈프레임에 관한 정보 역시 유지, 관리해야한다. 
- 페이지 테이블에 접근하고, 알아낸 실 주소를 가지고 실제 워드에 접근하는 두번의 메모리 접근이 필요해서, 실행 시간이 길다.
  - 사상이 요구될 가능성이 높은 테이블들은 메모리에 있어야한다. 
  - 혹은 연관 메모리를 사용한다.

### TLB
- 페이지 테이블에 접근, 실제 워드에 접근하는 메모리접근 시간을 줄이기위해, 고속 캐시를 이용한다. 
  - 비싸서 페이지 테이블의 일부 엔트리만 수용하는 크기다. 
  - 최근 빈번했던 엔트리들을 넣는다. 
- 페이지 번호를 키 값으로 동시 검색을 하게 되어, 순서는 상관이 없다. 
  - 페이지 번호도 함께 표시되어 있어야 한다. 
- TLB에 검색되는 엔트리들의 페이지는 모두 메모리에 있어서, 존재 비트를 확인할 필요가 없다.
- TLB의 크기만 충분하면 한 프로세스의 페이지 테이블 전체나 여러 프로세스의 일부분씩을 같이 넣을수도 있다. 
  - 이 경우, 페이지 번호, 프로세스 번호 모두가 있어야한다. 
- 접근 시간이 빨라지기 위하여는 TLB의 적중률 즉, 원하는 엔트리가 여기서 발견되는 확률이 높아야한다. 
  - 소량의 크기라도 90%이상은 나온다는 결과가 있다. 

### 페이지의 보호와 공유
- 보호: 페이지 테이블의 각 엔트리에 해당 페이지에 대한 보호비트를 둔다. 1이면 쓰기 허용, 0이면 트랩
  - 메모리ㅏ 공간에서도 프로세스들끼리 침범하면 안된다. 
- 공유: 프로세스 각자의 페이지 테이블에서 엔트리에 같은 프레임 번호를 가지도록 한다. 
  - 다수의 사용자가 한 부의 응용 프로그램을 공유하여 실행한다는 것은, 공유 프로그램 내에서 각자의 실행 위치는 다르지만 사용되고 만들어지는 각자의 데이터는 자신의 주소공간에 있고, 공유되는 프로그램은 코드 내용이 실행 도중 변하지 않아야하므로 재진입코드로 컴파일된다.
  - 각자 페이지 테이블에서 동일한 위치에 있다. 메모리에서 공유하는 명령어에서 페이지 번호가 같기 때문이다.

### 페이징에서 사상 테이블의 구성
32비트를 이용해 주소를 표현하는 시스템에서 메모리에 페이지 테이블을 모두 저장하기는 어렵다.
페이지 테이블을 작게 나누어 필요한 부분만을 메모리에 적재하기 위해 계층구조를 만들 수 있다. 
- 예) 2단계 페이징:: 페이지 번호를 나누어 메모리에 상주시키는 테이블과 , 페이지 테이블의 선택적 메모리 적재를 할 수 있다. 
  - 루트 테이블의 시작주소는 기준 레지스터에. 루트 테이블의 각 엔트리는 해당 페이지 테이블의 시작 주소를 가지게된다. 
- 메모리에 고정 크기의 페이지 테이블 하나만 둘 수도 있다. 이를 역 페이지 테이블이라 한다. 
  - 메모리의 프레임 수만큼 엔트리를 가진다. 
  - 이 경우 역으로 사상을 하므로 프로세스 번호도 함께 있어야한다. 
    - 따라서 서로 다른 프로세스 번호를 필요로 하는 공유는 구현하기가 어렵다. 
- 이 페이징은 고정 크기의 페이지로 메모리를 관리해서, 구현은 쉽지만 내부 단편화가 필욘적이다. 또한 하나로 붙어다녀야 효과적인 크기가 페이지 단위로 억지로 나눠지면, 사상 시간이 길어지거나 공유가 귀찮다. 

## 세그먼테이션
프로그램에서 주 프로그램, 프로시저, 함수 등으로 나뉘어있는 단위들로 구분이 가능한 서로 다른 크기들이 모여 전체 프로그램을 구성하는데, 이를 사상하고 적재하는 기법이 세그먼테이션이다.

- 세그먼트 개수만큼 세그먼트 테이블이 있고, 가상주소는 세그먼트 번호와 위치값으로 표현된다. 
  - 기준 레지스터에 세그먼트 번호를 더해 엔트리를 찾는 것은 페이징과 같다. .
- 엔트리는 존재 비트를 갖고 있다. 그리고 그 존재 비트 값에 따라 디스크 주소/메모리 주소를 가지는 필드가 있다.
  - 여기서 메모리 주소 필드는 실주소다.
- 세그먼트를 정교하게 제어할 비트를 접근 제어 키라고 한다. 
- 세그먼트는 다양한 크기의 메모리 적재를 위하여 배치 기법을 사용하지만 홀이라는 외부 단편화가 생길 수 있다.

### 세그먼트의 보호와 공유
- 보호: 세그먼트의 실주소를 위해 더해지는 위치값이 세그먼트의 길이값을 초과하면 트랩 실행.
  - 또한 접근 제어 키를 사용. 세그먼트 별 허용 작업 제어. 
- 공유: 페이지의 엔트리는 공유 테이블에서 같은 위치에 있어야 해서, 테이블의 구성을 힘들게했다. 
  - 세그멘테이션은 엔트리에서 같은 주소값을 가지게 하면 된다. 
- 논리적인 단위 =  보호와 공유.
- 세그먼트 크기가 달라져도 제어키를 사용, 추가 작업이 가능하다.
- 단위별로 수정, 컴파일해서 쓸 수 있다. 

## 페이징을 사용하는 세그멘테이션
- 프로그램을 세그먼트로 나누고, 그를 다시 페이지로 나눈다.
  - 매핑의 최종 단위는 페이지이므로 메모리는 페이지와 같은 크기의 프레임들로 구성되어있다. 
  - 세그먼트 테이블과 그 엔트리 개수만큼 페이지 테이블이 필요하다. 
  - 세그먼트 테이블의 각 엔트리는 페이지 시작주소를 가지고 있다. 
  - 최종 페이지 테이블의 시작주소를 얻은 후, 가상주소를 추가하면 프레임 번호를 알 수 있다. 그 다음 실주소에 접근한다.