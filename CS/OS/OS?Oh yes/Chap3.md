## 프로세스와 스레드

### 프로세스: CPU의 자원이 분배되어 일거리의 단위로 구분되어있는 것.
보통 수행 중인 프로그램이라는 표현을 사용한다.
- 프로세스 제어 블록
  - 시스템에서 프로세스가 생성되고 사라질 때까지의 모습, 테이블 자료구조를 가지고 있다.
  - 운영체제가 프로세스를 관리한다는 뜻은: 이 블록에 대한 행동인 것이다. 
  - 이 작업은 매우 빈번해서, 기본적으로 메모리에 저장시킨다. 
  - 프로세스 번호/상태(준비, 실행, 대기, 보류)/우선순위/카운터 값/메모리 포인터/문맥 데이터/할당받은 자원 목록/계정 정보(CPU 사용 시간)
- 프로세스의 상태와 변화
  - 생성: 사용자의 요청 작업이 커널에 등록, PCB 생성되어 준비나 보류준비 상태로 되기 위해 대기하는 상태
  - 준비: 생성되었으면, 운영체제는 메모리 공간을 검사, 충분한 공간이 있으면 할당 후 준비 상태, CPU만 주어지면 바로 실행할 수 있다. 큐 혹은 리스트가 사용된다. 
  - 실행: 순서에 따라 CPU 할당. 순서를 정하는 것을 CPU 스케줄링이라 한다. CPU를 할당하는 것을 디스패치라고 부른다. 단일 cpu 시스템에서는 오직 하나의 프로세스만이 실행되지만, 여러개일 경우는 여러개의 프로세스가 실행, 이를 다중처리라고 부른다. 
    - cpu 스케줄링 정책에 의해 cpu를 뺏길 수 있는데, 이 경우 준비 상태로 바뀌게 된다.
  - 대기: 프로세스가 실행되다가 입출력 처리를 요청하거나, 바로 확보될 수 없는 자원 요청하면 cpu를 양도, 요청한 일이 완료되기를 기다리면서 대기하는 상태다. 메모리는 가지고있다. 이 때도 큐 또는 리스트가 사용된다. 요청일이 완료되면 다시 실행차례를 기다리는 준비 상태로 바뀌면서 준비 큐에 들어간다.
  - 보류 준비: 생성된 프로세스가 바로 메모리를 받지 못할 때, 준비 또는 실행 상태에서 메모리를 잃게 될 때(CPU 반납 + 메모리 반납)
    - 준비 상태에서 메모리를 잃거나, 높은 우선순위의 보류 대기상태 프로세스가 준비 상태가 되면서 실행 상태의 프로세스로부터 cpu를 뺐길 때
    - 스와핑이 일어난다. 
  - 보류 대기: 대기상태일 때 메모리 공간을 잃은 상태. 준비 상태의 프로세스가 있다 할지라도 메모리의 여유 공간을 더 확보하기 위해 보류 대기상태가 되기도. 
  - 종료: 프로세스가 종료될 때 아주 잠시 거치는 상태. PCB만 커널에 남아있다. 
    - 운영체제가 시스템에 남겨진 프로세스 흔적들을 최종 정리, pcb를 삭제하면 프로세스가 완전히 사라진다.

  > 보류는, 메모리 공간의 여유가 없어지게 되었을 때, 당분간 메모리를 회수해도 문제되지 않을 프로세스를 골라 보류 시킨다.
  > 이는 모든 프로세스가 입출력 모드여서 프로세스들이 대기중일 경우도 마찬가지이다.
  > 
> 보류 상태란, 프로세스가 메모리 공간을 뺏기고 디스크로 나가야하는 것을 말한다. 
> 메모리 공간 확보, 바라던 것이 아닌 오류가 보일 때, 수상한 행동이 보일 때, 주기적인 일이라 메모리를 회수해도 문제되지 않을 때

### 스레드: 스케줄링의 단위. 
프로세스가 가지는 자원을 공유하고, 각자는 자신의 실행 환경 값들을 따로 가지게 된다. 
#### 다중스레딩이란 하나의 프로세스를 다수의 스레드로 만들어 실행하는 것이다.

- 스레드는 자신의 제어 블록(PCB와 비슷), 스택을 가진다. 
- 프로세스의 정보인 pcb와 사용자 주소 공간은 공유한다.
- 성능 측면에서 스레드의 가장 큰 장점을 찾을 수 있다.
  - 스레드 끼리의 스위칭 비용이 프로세스끼리의 스위칭 비용보다 적다.
  - 프로세스 간 통신은 커널이 필요하지만, 한 프로세스 내의 스레드 통신은 메모리와 파일을 공유해서 커널의 개입이 필요없다.

[//]: # (  - CPU의 할당 단위가 스레드다. 따라서 cpu 스위칭을 위한 스레드 단위의 자료는 유지되어야한다.)

- **스레드의 상태**
  - 스레드 역시 실행 준비 대기 상태가 있다. 하지만 보류는 프로세스 레벨의 개념이라 스레드에서는 필요가 없다.
    - 대기는 레지스터 값, 프로그램 카운터, 스택 포인터 등의 보관이 요구
    - 종료는 해당 스레드의 레지스터 값, 스택을 없애게된다.

- **스레드 동기화**
  - 아무래도 스레드끼리 메모리를 공유하기에, 특정 스레드 변경 내용이 다른 스레드에 영향을 바로 미치게되고, 이 과정에서 오류가 없기 위해 스레드 실행 동기화가 필요하다.

- **스레드의 종류**
  1. 사용자 레벨 스레드
  2. 커널 레벨 스레드

  - 사용자 레벨 스레드
    - 스레드 라이브러리에 의해 관리. 사용자 공간에서 스레드 관련 행위 이루어지므로 커널은 스레드의 존재를 알지 못한다. 
    - 이는 커널이 스레드의 행위를 프로세스의 행위로 인식한다는 뜻.
    - 특정 스레드의 실행에서 대기는 프로세스의 대기를 초래한다. 이때 스레드 라이브러리에 의해 실행으로 지속적 간주되고, cpu가 할당되었을 때 계속 실행하도록 도움을 받는다.
      - 이는 프로세스 스위칭이 커널에 의해 될 때도 마찬가지이다.
    - 커널의 개입이 스레드 스위칭에 필요없다. -> 모드 스위칭이 필요없다. 
    - 더불어, 운영체제가 정한 스케줄링에 따를 필요가 없어서 어떤 운영체제에서도 운영이 가능하다. 
    - 그러나, 특정 스레드의 대기가 자신의 속한 프로세스 내의 모든 스레드 대기를 초래한다. 
    - 더불어 ;스레드 단위의 다중처리는 불가하다. cpu가 프로세스 단위로 할당되기 때문
  - 커널 레벨 스레드
    - 다중 처리의 환경일 경우 다수 스레드는 각각 cpu를 할당 받아 병렬 실행이 가능하다. 
    - 한 스레드의 대기 시 같은 프로세스에 속한 다른 스레드로 스위칭이 가능하다.
    - 그러나 같은 프로세스에 속한 스레드 간의 스위칭에도 커널 개입이 필요. 모드 스위칭이 요구된다. 


