## CPU 스케줄링
CPU라는 자원은 한정되어 있기에,
메모리에 올라온 여러 프로세스들 중 누구에게 그 자원을 사용할 수 있게끔 할지를 결정하는 것을 스케줄링이라 한다.

### 스케줄링의 단계
스케줄링이 요구되는 시점을 기준으로, 
1. 장기
2. 중기
3. 단기 스케줄링으로 나뉜다.

- 장기 스케줄링 
  - 작업 스케줄링이라고도 불린다.
  - 일괄처리 -> 큐에서 대기시키고 장기 스케줄러를 거쳐 프로세스가 되며, 시분할 -> 접속시도 허용여부 결정
  - 요청된 일을 프로세스로 만들어 시스템에 일거리로 추가하느냐를 결정..
  - 수행 횟수가 적고, 대부분 FIFO이지만, 계산위주의 프로세스와 입출력 위주의 프로세스 수를 적절히 맞추기위해 프로세스 성격을 반영하는 방식을 사용할수도 있다.

- 중기 스케줄링
  - 보류 상태의 프로세스 중 어떤 프로세스에게 메모리를 할당해줄지를 결정한다.
  - 장기-단기의 중간 단계

- 단기 스케줄링
  - 준비 상태에 있는 프로세스들 중 어떤 프로세스에 CPU를 할당할지 결정하는것이고, 
  - 스케줄링의 대부분은 단기 스케줄링이다.
  - 입출력/시간 종료 인터럽트/시스템 콜과 같은 다양한 이유에 의해 가동되고, 매우 횟수가 잦아서 시간을 최대한으로 줄여야한다.

### 스케줄링의 목적과 기준
스케줄링은 결국 시스템의 성능을 높이기 위하여 하는 것인데, 
그를 평가할 기준은 이러하다.

1. 사용자의 입장에서는 응답 시간: 프로세스 요청에 대해 시스템이 최초로 출력을 내주기 시작할 때까지. 이를 위해서는 스케줄링을 자주해야할 것이고, 그러면 상대적으로 처리량이 감소.
2. 시스템의 관점에서는 처리량과 활용도: 
   - 처리량은 단위시간 내에 완료된 프로세스의 개수
   - 활용도는 주어진 시간동안 특정 자원이 실제로 가동된 시간의 비율

시스템의 종류마다 중요한 지표가 다르다. 
이를테면 인터랙티브한 시스템의 경우에는 응답 시간이, 일괄 처리 시스템에서는 처리량이 중요하다.

모든 것을 만족하는 것은 불가하다. 
목적에 따라 어떤 종류의 프로세스를 더 우대할지를 생각해야한다.

### 스케줄링 기법들
스케줄링이 가동되어야하는 시점은 다음과 같다.
1. 실행 > 대기: 입출력 요청
2. 실행 > 준비: 시간 종료와 같은 인터럽트
3. 대기 > 준비: 입출력의 종료
4. 프로세스가 수행을 마치고 종료될 때.

- 비선점 스케줄링: CPU 할당 시, 스스로 반납할 때까지 계속 사용하도록 허용함
- 선점 스케줄링: CPU 할당받은 프로세스로부터 CPU를 빼앗는다. 우선순위가 높은 프로세스에 CPU를 할당하는 방법이다.

주로 1, 4는 비선점/ 2, 3은 선점

#### FCFS 
- 준비 큐에 먼저 도착한대로 할당
- 시간이 오래걸릴 수 있으므로, 대화형에는 적합하지 않다. 
- 도착 순서만이 실행 순서를 결정짓는다는 관점에서 공평하다.
- 실제 시스템에 사용되기는 힘들지만, 다른 스케줄링 기법의 보조장치로 사용된다 (우선순위가 동일할 경우)

#### SPN (Shortest Process Next)
- SJF라고도 불린다. 준비하고 있는 프로세스들 중 가장 짧은 것부터 실행시켜주는 비선점 방식이다.
- 평균 응답시간을 줄여볼 수는 있지만, 긴 프로세스는 무한으로 기다려야할수도 있다.
  - 이를 보완하기 위하여, 오래 기다릴 수록 우선순위를 높여주는 에이징이라는 게 있다. 
- 실행해야할 프로세스 수가 충분하다고 하면, 처리량에 대해서는 훌륭하고, 빠른 응답을 보이나, 예측이 불가하다. 
  - 예측 가능성을 높이기 위해, 프로세스의 크기를 실행 전에 추정해보는 지수 평균을 도입해볼 수 있다.

#### SRT (Shortest Remaining Time)
- SPN을 선점 방식으로 운영하는 것이다. 
- 프로세스별로 완료값이 가장 짧게 남은 것부터 선점시킨다. 
  - 잦은 선점으로 인한 문맥교환이 잦다.
- 실제로 운영될 때, 잦은 문맥교환으로 예상보다 시간이 더 길어질 수도 있다. 
- 가까운 미래의 프로세스 정보를 알 수 있는 기법을 사용하여, 짧은 게 뒤에 도착한다하면 애초에 실행을 하지않아 문맥교환을 최소화할 수도 있다. 

#### HRRN (Highest Response Ratio Next)
- 비선점 방식
- SPN, SRT의 수행시간이 긴 프로세스의 무한 대기 현상을 방지하기위하여, 응답률이라는 개념을 도입한다.
- 이는 (대기시간 + CPU 요구량) / CPU 요구량이다.
- 프로세스 대기시간 높아지면 응답률이 높아지고, CPU 요구량이 많아지면 응답률이 낮아지므로, 짧은 거 먼저 하면서도 대기시간이 긴 것을 챙긴다.
- 스케줄링 할 때마다 계산한다.

#### Round Robin
- FCFS를 기반으로, 시간 할당량이 지나면 CPU를 뺏겨서 준비 큐에 들어간다.
- 한 프로세스의 긴 독점은 방지할 수 있지만, 문맥교환의 오버헤드가 있다.
- 대화식 시스템이나 시분할 시스템에 적합하다고 한다.
- 연산 위주의 프로세스가 입출력보다 유리하다. 그 이유는 입출력은 시간 할당량을 끝내기 전에 끝내고 준비로 들어가게돼도 할당량 남았던 것을 보상받지 못하기 때문이다.
  - 이 때문에, 입출력의 경우 큐를 따로 만들어서, 이전 입출력 발생했을 때 쓰지 못하고 남긴 시간 할당량만큼만 준다. 우선순위도 높다.
    - 이것을 가상 라운드로빈이라 부른다.
    **- 궁금한 점::: 남긴 시간 할당량만큼만 주는게 혜택인가요 ??**

#### 다단계 큐
- 정적 우선순위를 사용하는 스케줄링을 구현.
- 같은 우선순위 값을 가지는 프로세스를 위해 큐가 필요. 
- 우선순위의 개수만큼 큐가 필요.
- 우선순위가 낮을 경우 실행중이더라도, 높은 프로세스가 상위 단계 큐에 도착하면 선점당한다.

#### 다단계 피드백 큐
- CPU 요구량을 모른다 할지라도, 짧은 프로세스에 유리 + 입출력 프로세스를 우대하는 기법
- 동적 우선순위를 기반으로 하는 선점 방식. 시간 할당 인터럽트
- 우선순위가 높을수록 시간 할당량을 낮춤.
  - 이를 통해 긴 프로세스의 무한 대기를 줄인다.
- 우선순위 높은 것의 할당이 끝나면, 그 아래 우선순위 큐로 옮겨진다.
  - 상위 단계 큐들이 비어있는 동안에만 아랫 단계의 큐가 실행된다. 
- 제일 아래 우선순위는 라운드 로빈 방식
- 입출력의 경우 시간 할당량 끝나기 전에 CPU를 내놓으면, 우선순위를 올려준다.
- 여러 변형이 가능하다.

#### Fair-share 
- 프로세스 특성에 맞게 그룹으로 나누고, 그 그룹에 CPU를 할당한다.
- 그 그룹 내에서 프로세스 운영을 해서, 과도한 CPU 사용이 생길 때, 그 그룹 내의 프로세스에만 영향을 미친다.

### 실시간 스케줄링
실행될 모든 프로세스들이 정해진 모든 시간 내에 완료되어야한다. 
- 경성 실시간: 마감시간 내에 완료되지 않을시, 치명적 결과가 있는 시스템 -> 일반적인 실시간 
- 연성 실시간: 마감시간 내에 완료되지 않을시, 완료의 가치가 떨어지게되는 것.

- 정적 방법: 프로세스 특징과 개수를 알 수 있는 경우 -> 실시간은 대부분 알 수 있다.
- 동적 방법: 프로세스 특징 특성 알 수 없는 경우.

#### RM (Rate Monotonic)
정적 스케줄링 방식. 크기와 개수가 알려진 프로세스들이 각각 주기적으로 발생되는 환경에서 사용. 
- 주기가 짧을수록 높은 우선순위 
- 선점 방식
- 스케줄링 비용이 적게 드는 대신, 새로운 프로세스가 추가되는 환경에 바로 적응하지 못하고 전체 스케줄링을 다시해야한다. 
**궁금한 점: 그럼 굳이 선점일 필요가 있는건가?**
#### EDF (Earliest Deadline First)
프로세스 마감시간이 가까울수록 우선순위를 높게 부여
- 동적 스케줄링
- 새로운 프로세스 도착시 바로 대응할 수 있다. 
- 주기가 있을 필요는 없다. 잇으면 마감 시간을 주기로 한다. 
- 동적인 수용이 허용되지만, 그럴 때마다 가능한 스케줄을 찾기위한 계산을 해야한다. 

#### RM이나 EDF 모두 프로세스 간 통신에는 적용되지않는다.


## 윈도에서의 스케줄링
스레드 단위로 CPU를 할당한다. 
우선 순위에 의한 선점 스케줄링 방식.

실시간 클래스 16-31, 일반 클래스 0-15
- 실시간 : 정적 우선순위. 다단계 큐
- 일반: 동적 우선순위. MFQ
  - 스레드의 실행 동안 우선순위 변할 수 있는데, 스레드의 기저 우선순위의 하한보다는 낮아지지않는다. 


최초 우선순위 : 기저 우선순위 + 프로세스 우선순위

우선순위의 변동은 시간 종료 인터럽트는 하향, 입출력은 상향으로 우대.

