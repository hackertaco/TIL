NoSql의 프로그래밍 모델인 맵리듀스와 스파크.
- inter query 병렬: 한 노드에 한 쿼리. OLTP에 좋다.
- inter operator 병렬: 한 노드에 한 연산자. OLAP에 좋다.
- intra operator 병렬: 다양한 노드에 연산자. 확장성에 좋다. 

- 파티션 해시조인
- 브로드캐스트 조인
 
위의 두가지는 맵리듀스와 스파크에 중요한 조인 알고리듬이다. 

기존 관계형 데이터베이스 시스템을 확장하는 것은 consistency 측면에서 쉽지않았다. 그래서 NoSql과 같은 것들이 등장했고, MapReduce는 그를 컴퓨팅하는 프로그래밍 모델이다.

### MapReduce가 데이터를 저장하는 방식
- Distributed File System
    - 테라바이트에서 페타바이트까지 큰 파일을 저장하는데, 그를 파티션해서 청크로 나뉜 후 저장한다.
    - 이 청크는 복제되어 여러 rack에 저장된다. 장애 허용을 위함이다.

### MapReduce가 해결하는 문제들
- 많은 데이터를 읽기
- Map: 레코드로부터 중요한 정보를 추출한다. 
- 이후 셔플하고 정렬한다. 
- Reduce: aggregate, summarize, filter, transform

이는 쿼리를 나눈다는 점에서 기존 sql과 비슷하다. 

## Map
- input: input key, value
- output: intermediate key, value

## REDUCE
시스템은 모든 중간 키들을 그루핑하고, REDUCE 함수로 보낸다. 
- input: intermediate key, value
output: values (bag of output)

병렬로 작동한다. 
- worker들이 한번에 한 태스크를 실행한다.
- 얼마나 많은 코어가 컴퓨터에 있는지에 따라 워커 수가 달라진다. 보통 8 아니면 16

### Fault Tolerance
맵리듀스는 맵 결과를 디스크에 쓰고, 크래시가 나도 다시 진행할 필요는 없다. 리듀서는 디스크에서 결과를 가져와서 다시 실행한다. 

### 실행
- 한 머신이 리더 노드로 작동하고
- 인풋 파일을 파티션한다. 예를 들면 범위 기반 파티셔닝! 
- 각 워커들을 map 작업에 할당한다. 
- straggler: 너무 작업 오래 걸리게하는 노드. 이를 위해 맵리듀스는 빨리 끝난 노드를 해당 작업에 뛰어들게한다. 이는 맵과 리듀스 잡이 stateless하기에 가능하다. 
- 그런데 맵리듀스 작업에서, 맵만 필요하지 리듀스는 필요하지 않은 경우가 있다. 이를 스파크가 보완해준다. (ex. select job)
- skew가 생길 수 있다. 또 쓰기작업이 좀 느릴 수 있다. 

## Spark
- 기존 맵 리듀스는 복잡한 쿼리를 쓰기 어려웠다. 
- 더불어 모든 중간 결과를 디스크에 써야했기 때문에 속도가 좀 느렸다. 

그래서 버클리에서 스파크를 개발! 
- 반복을 포함해 여러 단계가 있다. 
- 중간 결과를 메인 메모리에 저장한다. 
- 관계 대수와 비슷한 것을 사용한다.

맵리듀스처럼, 데이터 모델이 있다.: RDD
- lineage를 가지고 있는데, 이는 어떻게 데이터 셋이 컴퓨팅 되었는지를 표현한다. 서버 크래시가 나면 메인 메모리에서의 RDD가 없어지나, lineage가 있으면, 재 컴퓨팅할 수 있다. 

스파크 프로그램은 
- Transformations: Lazy, 바로 실행은 안된다. 리니지 로그에 레코드 되고 바로 시행되지않는다. 이렇게 함으로써, 다양한 오퍼레이터를 그루핑하고 여러번 반복하지 않게끔 한다. 
- Actions로 나뉘는데, operators가 즉시 실행된다. 


### RDD 
- 로컬에서만 작동하는 것과 (RDD<T>)
- 여러 노드에 분배되는 것이있다. (SEC<T>)
- 맵리듀스처럼 맵 함수가 있다. 다른점은 RDD를 반환하는 것.

### Spark Persistence
크래시나면 재시작해야한다. 그런데 리니지가 있다. 
> persist() 함수를 통해서 결과를 중간에 저장한다. 

- 