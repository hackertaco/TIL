### Why
왜 NoSql이 등장했는가.

기존의 관계형 데이터베이스 앱에는 
1. OLTP: 짧은 트랜잭션
2. OLAP

NoSql은 큰 범위의 OLTP가 필요했다. 많은 유저들을 페이스북과 같은 앱들이 유치했기 때문이다.
그런데 트랜잭션에 필요한 2PL과 같은 것들을 실행하자니 스케일링이 어렵고 데드락 현상이 심했다. 그래서 consistency와 분석 OLAP는 좀 포기하고, 좀 간단한 데이터 모델을 도입하게 되었다.

예전에는 하나의 데이터 파일, 하나의 유저, 하나의 dbms 애플리케이션을 가지고 사용했어서 consistency가 쉬웠지만, 더이상 그런 애플리케이션은 별로 없다.

이제는 데이터베이스 서버와 클라이언트 애플리케이션을 분리하여 확장을 꾀한다. consistency가 더 어렵다. 그런데 이조차 클라이언트를 확장하는데 한계가 있었다.

이제는 애플리케이션 자체에서 아웃소싱을 해서, 데이터베이스와 따로 연결해주는 서버를 둔다. 지역별로 다른 곳에 웹서버를 두고 하나의 데이터베이스 서버와 연결한다. 그런데 왜 데이터베이스 서버는 여러개를 두지 않을까? consistency 때문이다. 웹 서버는 여러개라 여러곳에서 db의 데이터를 빼갈 수 있는데, 이 때 consistency를 지켜주어야한다. 

### 어떻게 데이터베이스를 복제할까?
1. 데이터 샤딩 (파티셔닝)
2. 데이터 replication

#### 파티셔닝
데이터베이스가 메인 메모리에 맞고, 쿼리가 머신들 사이에서 돌아다닌다 가정할 때, 처리량이 많다. 

이 때는, 데이터를 어느 머신에서 가지고 있는지만 알고있다면 쓰기는 쉽지만 읽기는 까다롭다. 조인을 한다고 가정했을 때, 조인한 결과가 반환되는 데 시간이 걸리기 때문이고, 쓰기한 뒤에 읽기를 할 때 해당 블록을 잘 붙잡고 있어야한다. 아니면 deadlock에 의해서 kill 될 수 있기 때문이다. 그래서 consistency 유지가 어렵다.

#### 복제
파티셔닝하는 것이 아니라 여러 복제본을 만드는 것. 시간을 줄이고 대역폭도 늘릴 수 있다. 복제본이기 때문에 문제가 생겼을 때 문제를 견딜수도 있다. 그러나 write 하는 비용이 커진다. 복제하기 때문에, 여러 복제품에 복제해주어야하기 때문이다.

결국 관계형 데이터베이스에서 스케일하기는 너무 어렵다. 
- partition: join
- replication: copy 의 비용이 있다. 

그래서, NoSQL이 조금 더 간단한 데이터 모델과 간단한 기능들로 등장했다. 

### NoSql의 기능
- Basic Availability: app 자체로 복구해야한다. no ARIES!
- Soft state: 인풋 없이 바뀔 수 있다. 
- 결과적으로 consistency:

## 데이터모델
1. key-value: 해시 함수로 비슷한 분포로 파티셔닝이 가능하다. 
2. extensible record store: wide-column store라 불린다. 두개의 데이터 모델이 있는데, key-value(rowId, record) 혹은 (rowID, columnID- field) 두가지다. 두번째는 훨씬 복잡한 검색을 할 수 있다.
3. document store: key-value 스토어에서 value는 종종 몹시 복잡하다. 조금 더 구조화된 데이터가 낫다. 그것이 바로 JSON! (자기표현적, 몹시 유연하다.)

## 관계형 데이터를 JSON으로 옮기기
관계형 릴레이션을 Root로 만들고, 각 어트리뷰트별 트리를 만들어 표현하면 된다. 

그런데 많은 관계들은 표현하기 더 어렵다.
- nested collections 는 표현하기 어렵다.

## JSON store로서의 몽고db
- BASE 시행. 
- MonglDB Query Language 이용! 
