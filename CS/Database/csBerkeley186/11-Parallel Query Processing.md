- speed up 하거나, scale up 하거나! 
- 이 병렬성에는 두가지가 있다. pipeline or partition

## Architecture : 어떤 방식이 제일 좋은지는 아직 밝혀지지 않았다.
- Shared Memory (많은 하이엔드 컴퓨터들에서 사용하는 방식)
- Shared Disk
  - 업데이트가 까다롭다. 동시성 제어가 필요하다. 
- Shared Nothing (Cluster)
  - 가장 흔하다. 
  - 상업적 하드웨어에서도 많이 사용. 
  - 하드웨어에도 의존하지않는다. 
  - 실행이 어렵다. 

## Query Parallelism
1. Inter Query Parallelism: 여러 쿼리 사이의 병렬 - 싱글 스레드
2. Intra Query Parallelism: 
   - 한 쿼리 내에서 이루어지는 Inter-operator (pipeline)
   - Bushy tree parallelism. Inter-operator
   - intra query: 하나의 조인이 여러 노드에서 발생하는! (partitioned)

### Intra-operator 병렬
어떻게 여러 디스크나 머신에 있는 테이블을 파티션할까? 
- 범위에 따른 파티션: equi-join, range, group-by에 좋다.
- 해시에 따른 파티션: equi-join, group-by에 좋다. 서로 다른 알파벳 순서의 인덱스도 다르게 위치할 수 있다.
- 라운드로빈: 로드를 분산할 때 좋다. 

무공유 아키텍처는 좋은 파티셔닝이 필요하다. 적절한 컴퓨터에 있지 않은 데이터를 네트워크로 옮겨올 필요가 없기 때문이다.

## Parallel Data Access
### SCAN
병렬로 테이블 스캔 후 결과값을 합치는 작업을 할 때, 
p 인덱스를 만족하는 튜플이 없는 머신은 스킵할 수 있게 되므로 range나 hash 파티션이 유리하다. 

각 파티션에도 인덱스를 붙일 수 있다.
그를 통해, 데이터가 어디에 위치한지 바로 알 수 있다. 
1. 검색
   - 따라서 한 노드에만 가면 된다. 그러나 라운드 로빈 방식은 검색 시 모든 노드에 가야한다. 
2. 삽입
   - 관련있는 노드를 찾아서 삽입
   - 키가 한개만 있어야할 때, 그것이 이미 있는지 아닌지를 검사해야하는데, 이 때 파티션이 적절히 되어있지 않다면 브로드캐스트로 검색 후 이를 찾아내야한다.

### Hash
#### 파티셔닝 
1. 머신들 사이에서 데이터를 hn 해시 함수로 셔플하여, 스캔되면 stream한다. (병렬을 위해 이 과정이 추가됨)
2. 그 다음 각 로컬 머신에서 hashing 진행! 

- 1번 과정을 통해 우리는 스피드와 스케일 모두를 올릴 수 있다. 
- 그러나 이 과정이 다 끝나야 2번 과정을 진행할 수 있다. 

#### 조인
머신이 많지 않으면 naive 방식으로! 
1. 셔플 해서 스캔단계까지 완료한다.

조금 더 공간이 있으면 Grace 방식으로! 
1. hashing은 같은 방식으로 하지만, 그걸 두배의 하드웨어 공간을 통해 진행. 
2. 그 이후는 로컬에서 진행 

- 스피드와 스케일 모두를 올릴 수 있다. 

### Sort
이 또한, 셔플을 먼저한다. 
- 셔플을 통해 각 머신에 범위를 나눠 저장한다. 
- 맨 마지막 단계에서 이를 합친다. 

### Aggregate
계층적으로 진행. 

### Group by 
로컬적으로 계산 진행하고, 
그 계산 값을 셔플해서 해싱한다. 

키값에 따라 전역적으로 계산값을 만든다.

### 해시 조인 대칭
이러한 병렬화는, 다른 작업들이 끝나기 전까지 기다려야한다는 문제가 있다. 
따라서 스트리밍하면서도 각 노드가 서로의 사이드에서 해시테이블을 할당한다. ex. A 해시테이블을 만들고 B 해시테이블에서 매칭되는 부분을 바로 확인한다. 

이러한 조인은 A가 이미 파티션이 완성되었다면 여러 머신들 간 B끼리만 셔플하는 것도 가능하다.

### 그 외
- 브로드캐스트 조인: A가 사이즈가 작다면 B의 파티션을 지닌 모든 노드에 그를 보내어 조인해도 된다. 
- 
