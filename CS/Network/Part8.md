## 01. RIP
- 표준 라우팅 프로토콜
- 속도, 회선의 신뢰도, 회선의 로드는 확인하지 않는다. 
- 오직 홉 수 15개만 신경쓴다.

## 02. RIP detail
> router rip
> network network-number

- classful하게 네트워크 인식한다.
  - 150.150.100.0이면 클래스B. 그런데 클래스 C로 서브넷을 하고 있는 것이다.
  - 이건 클래스 B로 인식한다. 
- 업데이트 정보를 못 받으면 6번까지는 기다린다. (총 180초 = invalid time)
  - 이후에도 없으면 hold down

- admistrative distance: 라우팅 신뢰성. 낮을수록 높다. 
  - 경로 정보를 동시에 받는다면 해당 값으로 경로를 판단하게된다. 

## 03. Distance-vector 라우팅 알고리즘에서의 문제점과 해결책
- 한번 배운 라우팅 테이블을 계속 전달하므로 업데이트가 모든 네트웤에 전달되는 시간이 많이 걸린다. (ex. rip 30sec에 1회)
- 이 시차 때문에 루핑이 생겨 엄청난 트래픽이 발생한다.

이를 해결하기위한 **대책마련**
1. Maximum hop count
   - 루핑이 발생하더라도 15를 초과하면 멈출 수 있다. 그러나 네트워크가 커지면 치명적이다. 
2. hold down timer
   - timer가 동작중인 상태면, 외부에서 라우팅 경로 정보를 받았을 때 원래 가지고 있던 hop 값보다 크면 무시한다. 
3. 스플릿 호라이즌 (중요)
   - 라우팅 정보가 들어온 곳으로는 같은 정보를 내보낼 수 없다는 개념
     - 두 라우터 간 루핑을 막아준다. 
4. 라우트 포이즈닝
   - 다운된 네트워크를 우선 무한대치 (hop16)으로 바꾼다. 라우터 테이블에서 지우지는 않는다. 
5. 포이즌 리버스
   - 라우팅 정보를 되돌려 보내되, 무한대 값을 보낸다. 

- VLSM: 인터페이스마다 가지게되는 여러 종류의 서브넷 마스크 (IP 주소의 효율적 이용을 위함)
  - RIP, IGRP는 못 사용한다.

## 04. IGRP 라우팅 프로토콜
라우터 포트에 연결된 회선의 종류와 설정된 대역폭 값에 따라서 지연 값을 계산한다.
- Bandwitdh, delay, reliability, load, MTU를 통해 경로를 찾아간다. 
> router igrp autonomous system number
> network network-number

## 05. OSPF 라우팅 프로토콜
프로토콜 넘버: 89, ip 패킷만 보아도 OSPF라는 것을 알 수 있다.
- 컨버전스 타임: 라우터끼리 변경된 정보를 주고받는데 걸리는 시간
  - ex RIP: 30s
  - OSPF: 바로 (area라는 것을 사용하는데 빠르고 효율적이다.)
- VLSM 적용해 IP 주소를 효과적으로 사용한다. 여러개의 라우팅 경로를 하나로 묶어준다. 
- 네트워크 크기 제한하지않는다. 따라서 먼 곳까지 전달이 가능하다. 
- 네트워크의 대역폭을 활용한다. 네트워크에 변화가 있을때만 정보를 날리기 때문에 훨씬 실용적이다. 
- 정확한 경로를 사용한다.
- 링크 스테이트 라우팅 알고리즘 사용

### OSPF 를 어떤 네트워크 타입에서 적용을 할 수 있는지? 이 타입 따라 약간씩 동작이 바뀐다.
- 멀티 액세스: 네트워크에 두개 이상의 라우터
- 포인트 투 포인트: 한쌍의 라우터, BR, BDR 선출하지 않는다.
- NBMA: 브로드캐스트하지 않는다. 2개 이상의 라우트 

### 어떻게 라우터와 교류? 
1. hello msg를 주위 라우터에 멀티 캐스트로 보낸다. 이때, 라우터 id(라우터 ip 주소 중 제일 높은 주소를 말한다.)
   - 예를들면 이더넷이 150.100.1.1, 150.200.1.1, 203.240.100.1 이 있다면 203~ 이 id다.
   - 만약 이 인터페이스가 자꾸 죽으면? id가 자주 바뀌는 것이라 좋지않다. 그래서 loopback 인터페이스를 사용한다. (잘 안 죽는 )

### DR, BDR
각각 반장과 부반장 같은 존재. 라우터들이 OSPF에 참여하게되면, DR, BDRdp link-state를 알린다. 
- DR 정보관리, 링크상태를 일치시킨다.
- BDR은 DR이 잘하는지 관찰한다. DR 죽으면 DR 역할을 대체한다.
- 선출 방법
  - priority가 높아야한다. 같으면 id가 높은 것이다. 
  - 중간에 새로 priority 높은 라우터가 와도 새로 선출하지는 않는다. 만약 dr이 죽어 bdr이 dr이 되면 bdr 선거를 하게된다. 
  - priority0 으로 세팅하면 입후보를 못한다.

### OSPF 링크 변화를 알아차리기
1. 링크정보를 DR에 전송(멀티캐스트 주소를 사용) - 링크정보는 LSA라는 곳에 담아 모든 DR에 전송한다. 
   - 이 때 BdR은 타이머를 세팅한다. DR이 정보를 다른 OSPF에 해당 정보를 재전송하는지를 감시한다. 
2. DR: 정보를 전송하고 다른 라우터로부터 ACK 받는다. 
3. 만약 BDR의 타이머가 끝날 때까지 LSA 정보를 전송하지않으면 BDR => DR이 된다. 
4. 링크가 끊어지면, DR에게 그 정보를 알리고 그 정보를 다시 OSPF router에 전송한다. 

### OSPF 구성
> router ospf process-id
> network address widlcard-mask area area-id

- wildcard-mask는 서브넷 마스크의 1을 0으로, 0을 1로 바꾸는 것
- area는 확장성 있는 라우팅 업데이트를 위한 값이다.
