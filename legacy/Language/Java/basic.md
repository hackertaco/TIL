### public class HelloPocu{}
무조건 클래스가 있어야한다.

최고 레벨의 public class는 하나만 
둘 이상일 경우 컴파일이 안된다. 

내포 클래스는 가능(클래스 안에 클래스)'

## main 함수
무조건 있어야하는.

## System.out.println(""")
- System은 클래스
- out의 자료형은 PrintStream 정적 클래스
- 오버로딩으로 println 가능.
- printf는 포맷팅이 가능. format() 메서드에서도 동일하게 동작된다. 
  - 여러 변수를 넣을 수 있는 이유는 가변인자 때문이다.


## 패키지 
printf는 내가 만들지도 않은 함수인데 사용할 수 있는 이유? 
p
어떤 걸 그룹짓는 방법. package
- java 기본 패키지
- 프로그래머가 직접 만든 패키지

이름을 지을 때는 도메인을 역순으로! 
폴더 구조가 반드시 패키지 순서여야한다.

## 빌드와 컴파일
컴파일
> javac -d class/path file.java

- 무사히 컴파일 되면, class 파일이 나온다. 
- -d는 경로옵션

실행
> java -classpath <class 파일 위치> <클래스 이름>

- -classpath 
- 클래스 파일의 위치를 알려주는 옵션. 
- 컴파일을 하면, exe파일이 나오는 게 아니고, .class 파일이 나오는데, 그 바이트 코드를 실행하는 명령어다.
- 클래스 이름은 상위폴더까지 정확하게.

배포
- .jar 파일을 만든다. 
- lib 폴더를 추가하여.
> jar <option> <jar 파일 이름> <최상위 패키지 경로>

.jar는 사실 .zip 
manifest 파일도 있다.
자바 애플리케이션의 정보를 담는 메타데이터 파일. 
메인함수에 대한 정보를 담어야한다. 
manifest.txt를 src 아래에 둘 것.
>jar -cfm 파일이름 매니페스트경로 최상위 패키지 경로

## 외부 패키지 내의 클래스 사용하기
import PACKAGE;
> import 패키지이름.클래스이름

## java.lang
기본 패키지.
모든 .java 파일에 자동으로 임포트 된다. 
그래서 println()을 임포트없이 사용할 수 있다.

---

## 자바의 실행 모델
- 크로스 플랫폼
  - 여러 플랫폼에서 실행할 수 있다는 의미
자바는 그렇기도 하고 아니기도 하다.
  - 코드를 컴파일 한 겨로가는 바이트코드(.class)
    - JVM이라는 프로그램이 이해하는 명령어. 
    - 이는 실행 중에 최종 플랫폼에 맞는 명령어로 바꾸어 실행해준다. 기계가 이해하는 방식으로 바꾸어주는 것.
    - JVM은 운영체제에 설치하는 별도의 프로그램이다. JVM에서 알아서 해주기 때문에, 바이트 코드 자체는 크로스 플랫폼이다.

    - 그치만, JVM이 설치되어 있지 않다면 자바 프로그램이 실행 불가다. 
      - 그래서, 크로스 플랫폼이라 하기에는 좀 어폐가 있다.
      - 최신에는 실시간으로 컴파일해주기도. 

## 자바가 인기 많은 이유
예전에 애플릿이라는 것 때문에! 웹에서 실행할 수 있게끔 도왔다. 

## 구조적 프로그래밍 요소
- 부호 있는 자료형만 존재 -> 왜 안고치나? 그냥 다 모르니까 깔끔히 지운다.
  - 이러면 0보다 작은 무엇인가를 넣어도 문제가 생기지않는다.
  - 코드를 방어적으로 작성해야한다. 쓸데없는 if 문들이 만들어진다. 
  - 보완하기위해 Integer를 ..
- 자료형 비트는 고정.

## char, String
### char
- 유일, 부호없는 자료형. 
- 근데 4바이트까지 표현 불가 
- 2바이트 넘어가면 String 사용해야한다. 

### String
- 연속된 문자를 표현하는 클래스형.
  - 이는 언제나 참조형
- 연속된 문자를 저장하는 메모리

### String, new 
String은 변경 불가다. 자바에서는!
바꾸고 싶다면 새로운 문자열을 만들어야한다.

---
## 리터럴
- int 리터럴: 없다
- long 리터럴: L or l
  - 생략가능
  - int보다 큰 수일 때는 생략하면 컴파일 오류

- float: F, f / 소문자 더 많다.
- double : 생략함 보통(d, D)
- 16진수 0x
- 유니코드 \u
- null
  - 참조형에 사용가능한 리터럴.
- _
  - 큰 숫자의 가독성을 높이기 위해 사용한다. (가독성 위해)

## final
- 상수형 변수. 
  - const 대신! 
  - final int MAX_STUDENT와 같은.
    - 바꾸려하면 컴파일 오류.
- 지역변수, 클래스 멤버변수, 메서드 매개변수, 클래스와 메서드에 붙일 수 있다.

### 초기화
1. 선언과 동시에
2. 사용하기 전에만
   - 지역 변수일 경우 사용 전에만
   - 멤버 변수일 경우 함수가 언제 호출될 수 있을지 모르기 때문에, 생성자에서 초기화 가능이다. 

자바의 /** 주석!
자동으로 JAVA API 문서를 생성해준다. 

---
## 대입연산자, 논리연산자, 캐스팅
- 대입연산자
  - = 대입
  - 값형과 참조형이 서로 다르다.
  - 참조형일 경우, 같은 공간에 대한 참조를 한다. 
- 캐스팅
  - 명시적으로 자료형 바꾸기. 
  - 암시적으로 바꾸는 자료형 

---
문자열에 저장되어있는 것은, 값이 아니고 메모리 주소라서 ==가 비교하는 것은 주소값이다.

근데 주소를 공유하는 경우가 잇다. String을 new로 생성하지 않은 경우다! (string constant pool)

그렇다면, 문자열 자체는 어떻게 비교해야할까? 
- equlas() 메서드를 사용하여야한다. 
> public boolean equals(Object obj);

- C#에서는 연산자 오버로딩 지원된다. 
  - 자바에서는 String용 +, +=만!

---
비트 연산자: >>>가 전용으로 더 있다. 
부호 없는 경우로 만들려고, 연산자를 따로 만든다.

--- 
Java는 switch문에서 break를 안하면 그냥 fall-through로, 모든 케이스를 진행한다. 
---
Java에는 goto가 없다. 
goto와 비슷하게, break 라벨이름이 가능하다.
근데, break를 감싸고 있는 라벨로만 점프가 가능하다! 
continue 역시 라벨 사용 가능하다. 
--- 

참조형 인자로 넘길 때 조심! 
final을 붙여도 바뀐다. 
참조형 변수는 주소를 저하기 때문에, final이 붙으면 주소만 변경하지못하고, 그것이 가리키는 값은 여전히 바뀐다.
--- 
자바도 열거형이 가능.
그러나 안되는 게 있다. 원하는 수 대입 불가. 생성자를 추가할 수 있으니, 
`enum Subject{ 
  KOREAN(2)
}`
이렇게 사용 가능!

---
람다: 링큐는 지원하지않지만, 람다는 지원.

---
모듈: 패키지에서 좀 더 발전되게끔. 

런타임 중에 사용중인 클래스 목록을 찾는 방법이 없다. 
따라서 사용 중인 패키지에있는 모든 클래스를 같이 배포하게되면서, 덩치가 너무 컸다

그래서 생긴 모듈?! 패키지보다 상위 개념.
정말 필요한 패키지만 포함 가능하고, 누락된 모듈을 확인할 수 있다. 
module-info.java -> 컴파일 중에 클래스로 바뀐다. 와 같은 파일에 그 목록을 다 적어놓는것이다.
>module pocu.academy.core{
>   exports pocu.academy.core.math; // 원하는 익스포트 클래스 기재
>   requires java.sql; // 외부모듈
> }
