개체를 생성 후에, 깜박하고 데이터를 대입하지 않을 경우 예기치 못한 문제가 발생할 수 있다.

-> 이를 해결하는 것이 생성자. 더 안전하게 oop 사용 가능
 
> public Car(int price)
> { Price = price; }

여기서 매개변수 안 넣으면 컴파일 오류가 난다.

- 생성자 개체를 생성할 때 반드시 호출되는 함수
- 함수명으로 클래스명을 쓴다.
- 반환형을 아예 적지 않는다. 
- 생성에 필요한 매개변수를 강제할 수 잇다. 
- 생성자가 여럿이어도 된다.
- 생성자 오버로딩

만약, 그냥 멤버변수가 같은 값을 가지는 경우에는
애초에 생성자 안에서 상수를 바로 대입한다.
아니면 변수 자체에 대입.

멤버변수는 기본으로 0이다.
참조형은 null이다. 
- 멤버 변수일 때만 초기화 생략 가능.

### 접근제어자
바뀌면 안되는 멤버 변수의 기본값이, 개체 생성 후에 변경되는 경우! 
외부에서 변경하지 못하게끔 하려면? **접근 제어자** 사용

- public
  - 누구라도 접근 가능
    - 클래스 내외로
- private
  - 클래스 안에서만 접근이 가능하다. 
  - 변수나 함수 모두 private 가능하다! 
- protected
- internal

근데, public도 아니고 private한 것도 아닐 경우? 

예를 들면 멤버 변수가 private인데, 그럼 클래스 바깥에서는 값을 확인을 못한다.

-> 읽기가 안되는 문제

조건을 걸기가 어렵다. 
-> 그냥 public이면 조건을 못지킬수도 있다.

- 일반적인 해결법은 getter/setter 함
  - 멤버 함수로 get, set 함수를 만드는 것이다. 

> public getGas(){ return private 변수 ;}

- 순수하게 대입을 하거나, 순수하게 반환하는 걸 getter/setter 함수라 한다.

#### 그런데 굳이? 다 이렇게 함수? 변수 접근하는 건데? 
좀 더 나은 방법? **프로퍼티**!

```typescript
public int Price
{
    get
    {
        return Price;
    }
    set
    {
        if(value >=505050)
        {
            Price = value;
        }
    }
}
```

- 변수와 메서드가 모두 함께 있는 형태!
- 이는 getter, setter를 정의하는 것이라 보면 된다. 
- 컴파일러가 알아서 getter, setter 함수를 만들어 주는 것이다. 
- 추가적인 논리 코드도 넣을 수 있다. 

- 자동으로 프로퍼티를 구현하기도 ! 

> public string Owner {get; set;}
> 
> public float Gas { get; private set; } = 10.0f;

- 컴파일러가 컴파일 시 익명의 멤버 변수를 만들어 줌.
- get과 set에도 접근 제어자를 붙여줄 수 있음.
- 메ㅁ버 변수에 단순히 데이터를 대입하거나 반환만 할 때 사용
  - 로직은 수동 프로퍼티 사용해야한다.

프라이빗 메서드는 소문자로 시작.

## 코딩 표준
다음과 같은 순서로.
1. public 멤버 변수/프로퍼티
2. private 멤버 변수
3. 생성자
4. public 멤버 함수
5. private 멤버 함수

그치만, 프로퍼티와 대응하는 private 멤버 변수는 프로퍼티 바로 위에 적음

프로퍼티를 쓸 수 있으면 써라! 

- public 멤버 변수/프로퍼티
  - 파스칼 표기법
- private 멤버 변수
  - 맨 앞에 m 붙이고
  - 낙타 표기법 따른다
- 함수의 매개변수, 지역변수
  - 낙타 표기법 따른다. 

멤버 함수의 경우, 
- public
  - Pascal
- private
  - Camel

## Partial 클래스
클래스를 쪼개는 것:: 

클래스 안에 또 클래스가 있는 것! 

클래스 또한 함수처럼, 
그냥 너무너무 커서 쪼갠거면 좋지않다. 재활용성이 없기 때문이다.


> public partial class Human
> {}

- 각 단어의 첫 글자는 대문자로!

이렇게 하면 실제로 사용하는 사람은 파셜에 대해 신경 쓸 필요가 없고, 
코드를 짜는 사람만 열심히 고민해서 짜면 된다.

## 정적 클래스
static! 
지겹게 본 스태틱. 
C#은 oop, 하지만 oop처럼 쓰지 않기 위해서는 static이 필요하다!

static const 불가! 
상수는 묵시적으로 static

static이 있는 순간 개체에 소속되는 게 아니다. 
- 클래스에 속하는 것이다.
- 따라서 모든 개체가 하나의 정적 멤버 변수를 공유하게 된다. 

>호출할 때, 클래스.함수() 형태로! 
> 정적 멤버 함수는 비정적 멤버 변수에 접근할 수 없다. 

static은 굳이 클래스.뭘 할필요가 없었다. 


클래스에도 static을 붙일 수 있다!
대신, 정적 멤버만 가질 수 있다.
new로 개체를 생성할 수 없다. 
개체를 생성하지 않고 정적 클래스 내의 함수를 사용 가능.
주로 유틸리티 클래스를 만들 때 사용한다.

### 왜 ? 사용? 
- 전역으로 공통되게 쓰고 싶은 값이 있으 ㄹ대.
- 프로그램 전체에서 개체에 종속되지 않은 기능 필요할 때.
- 한 클래스에 속한 모든 개체가 공통적으로 가지고 있는 데이터에.
- 개체를 구성하는 필수는 아니지만 그 개체와 연관있는 데이터에 사용.
- 정적 클래스는 이런 정적 변수와 함수를 모아두는 것이다.

## 확장 메서드
### 정적 클래스를 만든다
> public static class StringExtension{}

### 정적 함수를 만드는데, 확장 메서드를 작성한다.
- 확장 메서드의 첫번째 인자는 함수에 넣고자 했던 클래스 이름을 넣는다. 
- 첫번째 인자 앞에는 반드시 this를 붙인다. 

> public static void MyFunc(this int n, int m){}
### 언제 사용하나? 
- 클래스에 함수를 추가하지 못할 때
  - 해당 클래스의 소스코드가 없을 때.
  - 추가하려는 함수가 클래스에 필수적이지 않을 때

### 확장 메서드임을 강조해라. 
- 접미사로 Extension을 붙인다.
- 확장 메서드는 다른 파일에 
- 기본형의 확장 메서드를 만들 때는 조심
- 클래스형의 확장 메서드는 괜찮다.


