변수는, 스택 메모리에 저장된다. 
> Q. 주소를 내가 직접 쓸 수 있나? 
> 
> A. C에서만 가능. 사고를 칠 수 있다는 점 주의

---

## 주소 연산자 &
메모리 주소 = &변수명

- 보통 주소를 보여줄 때에는 16진수로 표현한다. 
  - > printf(%p, &num)
- 실행 때마다 주소가 달라질 수 있다. 
  - 요즘 운영체제에서는 보안 강화를 위하여, 실행 때마다 주소를 바꿔준다. 

---
## 메모리 주소 저장하기
> Q. 주소 자체를 변수에 저장할 수는 없나? 
>
> A. 컴파일 오류 어떤 게 주소고 어떤 게 값인지 모른다. 그래서 주소 저장을 위한 특별한 변수가 필요하다. 그는 바로 포인터

### 포인터란, 주소를 저장하는 변수형이다.
- 이 메모리에 저장된 자료형을 하드웨어는 신경쓰지 않는다. 따라서 char, int, float 로 읽는 방식은 상관하지 않는다. 
- 그러나, 해당 주소에서부터 몇 바이트를 읽어야 하는지는 하드웨어에 알려주어야 한다. 
- 포인터 변수 선언 시, 그 주소에 어떤 형이 있는지 명시해야한다. 
ex. int*, float*...
- 메모리 주소 저장 변수는 메모리 어딘가에 저장된다. 

---
포인터 저장된 주소는 바굴 수 있다. 
함수의 매개변수로도 가능하다. 
- *변수명. 
- 이를 역참조 연산자라한다. 그 주소위치에 가서 그 값을 읽어오는 것이다.
---
## 참조와 역참조
**포인터가 하는 일 = 참조**
이는 실제 데이터에 간접적으로 접근을 한다. 간접 연산자라고도 한다. 
> *pointer = 50; 

이 경우 실제 데이터 값을 변경하는 것이다. 원본에 접근 가능하다. 간접적으로!


--- 
그래서 포인터는 참조에 의한 전달? 값에 의한 전달? 
값에 의한 전달이라는 게 언어적으로는 맞다. 왜냐면 주소값을 전달하는 것이기 때문에. 

그런데 또 원본이 바뀌는 거니까 참조에 의한 전달이기도 하다. 
즉 이 논쟁에서 중요한 것은 참조에 의한 전달인지 값에 의한 전달인지가 중요한 것이 아니라, 

원본이 바뀌는지 아닌지가 중요한 것이다. 

---
### 포인터와 함수 반환값
return &result;라고 끝내면, 

유효하지 않다. 스택 메모리를 기억해보자! 

즉 예측하지 못한 결과가 발생할 수 있다. 
컴파일 오류는 나지 않지만, 이는 위험하기 때문에 작성하면 안된다. 즉 포인터를 반환하지 말어라!!!! 

**이를 댕글링포인터라 한다**
- 포인터를 반환해도 되는 경우는 
  - 전역 변수
  - 함수 내 static 변수나 파일 속 static 전역 변수 (이들은 데이터 섹션 속 애들이다)
  - 힙 메모리 생성 데이터


그렇다면 언제 포인터를 반환하면 도리까? 
> 도우미 함수 속 생성 변수를 다른 함수에서 사용하고자 함수 안에서 대용량의 데이터 생성할 때, 그 후 그것을 반환하고자 할 때, 이 경우는 힙 메모리가 된다. 

---
 ### 반환할 주소가 없는 경우? 
NULL! 사용
아무것도 가리키지 않는 것이다. 
> int* num_ptr = &number; 
> 
> num_ptr = NULL;

값이 0인 상수 표현식 혹은 void*로 캐스팅된 표현식 
헷갈림을 방지하기 위하여 매크로 쓰는 걸 추천 #define NULL (void*(0)) => 널을 발견하면 저걸로 바꿔다오~ 
ptr == NULL로 비교도 가능하다. 

### NULL이 가지는 문제들
- 매개변수
  - 너무 if문으로 분기처리를 많이 해야하기에 그냥 없다고 가정한다. 
- 반환값
  - 이 또한 그냥 없다 가정하고, 함수명에 or_null 붙인다. 
  
### 그렇다면, 언제 null을 사용할 수 있는가? 
1. *포인터를 초기화하고 싶을 때 (안정성을 위하여, 성능이 중요하면 초기화하면 안된다.)
2. 포인터 변수가 유효한 주소를 참조하고 있는지 확인하고 싶을 때 
   - 아무것도 가리키지 않는 포인터 변수를 역참조하면 결과가 정의되지 않는다. 
   - NULL이 아니면 역참조가 되게된다. 
3. 댕글링 포인터를 막기 
   - 더 이상 사용할 수 없는 데이터를 초기화해야한다. 

존재하지 않는 메모리 주소에서 값을 읽으면 문제가 나온다. 

---
## 포인터의 비교
### 포인터의 크기
주소의 크기는 컴퓨터 따라 다르다. 보통 cpu가 한번에 처리할 수 있는 데이터 크기와 동일하며, 32비트일시 4바이트, 64비트일 시 8바이트다. 

여기서 생각나는 것: sizeof

### 배열과 포인터는 몹시 비슷하다. 
배열은 시작 주소를 가진다.
> int* ptr = nums;
&nums[0]=ptr=nums

- 배열 속에서 각 요소 위치: 바이트 간격이 일정하다. 
- 포인터에 정수를 더하는 것은 데이터를 n개 건너뛴다는 것이다. 

## 한 바이트만 옮기고 싶다면
해당 주소에서 캐스팅 ! 
`int* int_ptr = int_array;
int_ptr = (char*)int_ptr+1;`
이 경우, char로 딱 한 바이트만 옮기게 된다. 

## 두 주소간 사칙연산
**주소에는 정수만 더하거나 뺄 수 있다.**
두 주소간 뺄셈 제외하고는 주소끼리의 연산은 불가하다. 

## 포인터변수는 안전하지 않다
기본형 제외하고는 자바나 C#에서 내부적으로 동일하게 포인터를 쓴다고 할 수 있다. 
그런데 포인터 변수를 사용하지 않는 이유는? 
주소 이동을 허가하지 않기 때문이다. 이는 안전하지 않다. 

그러나, 안전하지 않다고 해서 안 쓰기엔 너무 강력하다. 값을 복사하는 것보다 주소에 접근하는 게 훨씬 빠르기 때문이다. 

* 훌륭한 프로그래머 -> 안 쓰는 것보다는 잘 스도록 해야한다. 

## 포인터와 배열의 차이
1. sizeof 연산자
   - sizeof(배열) = 배열의 크기
   - sizeof(포인터) =포인터의 크기
2. 문자열 초기화
   - c는 문자열이 없다. char 배열로 이용한다. 
   - ex. Friday 는 F/r/i/d/a/y/\0으로 표현
   - 마지막에 null 문자가 들어간다. 
   - 초기화 방법은, 
     - 배열 charday1[]= "Monday";
       - 이는 스택에 저장된다. 함수 안에서 사용하면 그 때 복사해서 스택에 넣는다. 그전에는 미리 저장된 공간이 있다.
     - char* day2 = "monday";
       - 스택복사되지 않고 데이터 섹션 그대로 가리킨다. 
     - 스택에 저장된 문자열은 수정이 가능하지만, 데이터 섹션은 수정이되지않고 읽기 전용이다. 
3. 대입
   - 포인터 변수에 값을 대입할 수 있다. 
   - 배열 변수에는 할 수가 없다. 
4. 포인터 산술연산
   - 포인터에 배열주소 대입 후에 가능하다. 

## 연산자 결합 법칙
우선순위 연산자를 실행한다. 대부분이 왼 -> 오로 수행되는데, 문제는 포인터 연산자다. 

포인터 연산자의 경우, 
1) ++, --(후위 연산): ->
2) ++, --(전위 연산), * : <-

애매하면 괄호를 쓰는 게 나을지도 

## 조금 더 빠른 배열의 요소 더하기 함수
포인터는 이미 다음 위치에 가 잇고, 배열은 첫 시작부터 sizeof * index를 해야한다. 

## 포인터와 const
1) 주소를 보호한다. 
포인터 변수에 const 를 붙이면 const 포인터는 메모리 주소를 바꿀 수 없다. 

오른-> 왼으로 읽어야한다. int* const p 로 읽는다.

반면에 주소를 통하여 값을 못바꾸게 하려면, 
int const* p로 해야한다. 

- 주소와 값 모두 못 바꾸게 하려면
  - const int* const p 
  - 그러나 이는 생각보다 유용하지않게 쓰인다. 전역변수나 구조체 멤버변수 정도가 유용하지. 
- 그냥 const 제거하지말것. 캐스팅도 금지

