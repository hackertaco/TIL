변수는, 스택 메모리에 저장된다. 
> Q. 주소를 내가 직접 쓸 수 있나? 
> 
> A. C에서만 가능. 사고를 칠 수 있다는 점 주의

---

## 주소 연산자 &
메모리 주소 = &변수명

- 보통 주소를 보여줄 때에는 16진수로 표현한다. 
  - > printf(%p, &num)
- 실행 때마다 주소가 달라질 수 있다. 
  - 요즘 운영체제에서는 보안 강화를 위하여, 실행 때마다 주소를 바꿔준다. 

---
## 메모리 주소 저장하기
> Q. 주소 자체를 변수에 저장할 수는 없나? 
>
> A. 컴파일 오류 어떤 게 주소고 어떤 게 값인지 모른다. 그래서 주소 저장을 위한 특별한 변수가 필요하다. 그는 바로 포인터

### 포인터란, 주소를 저장하는 변수형이다.
- 이 메모리에 저장된 자료형을 하드웨어는 신경쓰지 않는다. 따라서 char, int, float 로 읽는 방식은 상관하지 않는다. 
- 그러나, 해당 주소에서부터 몇 바이트를 읽어야 하는지는 하드웨어에 알려주어야 한다. 
- 포인터 변수 선언 시, 그 주소에 어떤 형이 있는지 명시해야한다. 
ex. int*, float*...
- 메모리 주소 저장 변수는 메모리 어딘가에 저장된다. 

---
포인터 저장된 주소는 바굴 수 있다. 
함수의 매개변수로도 가능하다. 
- *변수명. 
- 이를 역참조 연산자라한다. 그 주소위치에 가서 그 값을 읽어오는 것이다.
---
## 참조와 역참조
**포인터가 하는 일 = 참조**
이는 실제 데이터에 간접적으로 접근을 한다. 간접 연산자라고도 한다. 
> *pointer = 50; 

이 경우 실제 데이터 값을 변경하는 것이다. 원본에 접근 가능하다. 간접적으로!

### 포인터로 두 변수의 값을 바꾸기
```vue
void swap(int num1, int num2)
{
    int tmp;
    tmp = num1;
    num2 = tmp;
}
```
```vue
void main(void)
{
    int num1 = 20;
    int num2 = 10;
    
    printf("num1: %d, num2: %d\n", num1, num2);
    swap(num1, num2);
    printf("num1: %d, num2: %d\n", num1, num2);

    return 0;
}
```
위의 경우, 두 값은 바뀌지 않는다. 스택 메모리에 값을 복사하기 때문이다. 
포인터로 둘을 바꿀 수 있다. 

```vue
void swap(int* num1, int* num2)
{
    int tmp;
    tmp = *num1;
    *num1 = *num2;
    *num2 = tmp;
}
```
```vue
void main(void)
{
    int num1 = 20;
    int num2 = 10;
    
    printf("num1: %d, num2: %d\n", num1, num2);
    swap(&num1, &num2);
    printf("num1: %d, num2: %d\n", num1, num2);

    return 0;
}
```


--- 
그래서 포인터는 참조에 의한 전달? 값에 의한 전달? 
값에 의한 전달이라는 게 **언어적**으로는 맞다. 왜냐면 주소값을 전달하는 것이기 때문에. 

그런데 또 원본이 바뀌는 거니까 참조에 의한 전달이기도 하다. 포인터를 이용해서 참조에 의한 전달을 흉내내는 것이다. 
즉 이 논쟁에서 중요한 것은 참조에 의한 전달인지 값에 의한 전달인지가 중요한 것이 아니라, 

원본이 바뀌는지 아닌지가 중요한 것이다. 

---
### 포인터와 함수 반환값
포인터도 변수라서 함수 반환값으로 사용이 가능하다. 
그러나 주의할 점이 있다.


return &result;라고 끝내면, 

유효하지 않다. 스택 메모리를 기억해보자! 
함수의 지역변수는 스택에 저장된다. 

- 함수 호출이 끝나면 지역 변수도 사라진다.
- 그 주소까지 사라지는 것이 아니라 컴파일 오류는 나지 않는다. 그러나, 
- 포인터가 유효하지 않은 주소를 가리키는 것은 위험하다. 즉 예측하지 못한 결과가 발생할 수 있다. 

**이를 댕글링 포인터라 한다**
- 포인터를 반환해도 되는 경우는 
  - 전역 변수
  - 함수 내 static 변수나 파일 속 static 전역 변수 (이들은 데이터 섹션 속 애들이다)
  - 힙 메모리 생성 데이터


그렇다면 언제 포인터를 반환하면 될까? 
> 1. 도우미 함수 속 생성 변수를 다른 함수에서 사용하고자 할 때! 단, 일반 지역 변수는 불가.
> 
> 2. 함수 안에서 대용량의 데이터 생성할 때, 그 후 그것을 반환하고자 할 때, 이 경우는 힙 메모리가 된다. 

---
 ### 반환할 주소가 없는 경우? 
NULL 포인터 사용
아무것도 가리키지 않는 것이다. 
> int* num_ptr = &number; 
> 
> num_ptr = NULL;

값이 0인 상수 표현식 혹은 void*로 캐스팅된 표현식 
전용 매크로도 있다.

헷갈림을 방지하기 위하여 매크로 쓰는 걸 추천 
> #define NULL ((void*)0) => 널을 발견하면 저걸로 바꿔다오~ 

- 포인터 변수와 NULL은 비교 가능

ptr == NULL로 비교도 가능하다. 

- 코딩 표준: 매크로 NULL을 반드시 사용할 것

### NULL이 가지는 문제들
복잡성이 증가한다.
기본적으로 NULL이 안 들어온다고 가정하고 함수 작성해야 코드가 깨끗! 

- 매개변수
  - 너무 if문으로 분기처리를 많이 해야하기에 그냥 없다고 가정한다. ex) student_id_or_null
  - assert()를 사용하여 검증하자.
- 반환값
  - 이 또한 그냥 없다 가정하고, 함수명에 or_null 붙인다. ex) get_name_or_null
  - return NULL
  
### 그렇다면, 언제 null 포인터를 사용할 수 있는가? 
1. 포인터 변수를 초기화하고 싶을 때 (안정성을 위하여 작업하는 것, 성능이 중요하면 초기화하면 안된다.)
2. 포인터 변수가 유효한 주소를 참조하고 있는지 확인하고 싶을 때 
   - 아무것도 가리키지 않는 포인터 변수를 역참조하면 결과가 정의되지 않는다. 
   - NULL이 아니면 역참조가 되게된다. 
   - 역 참조를 하기 전에 널 포인터인지 확인해야한다.
3. 댕글링 포인터를 막기 
    - 동적 메모리 할당된 메모리를 필요없어서 해제했는데도 불구하고, 이를 여전히 가리키는 포인터가 있다면::
      - 더 이상 사용할 수 없는 데이터를 초기화해야한다. 이 때 널 포인터 사용

존재하지 않는 메모리 주소에서 값을 읽으면 문제가 나온다. 

---
## 포인터의 비교
포인터는 비교 연산자를 이용해서 서로를 비교할 수 있다. 
- 근데 왜 주소를 비교하지?
  - 큰 메모리 통째로 잡아두고 그 안에 복수의 데이터를 넣어서 사용할 때 필요하다.
  
### 포인터의 크기
주소의 크기는 컴퓨터 따라 다르다. 보통 cpu가 한번에 처리할 수 있는 데이터 크기(=워드)와 동일하며, 
32비트일시 4바이트, 64비트일 시 8바이트다. 

여기서 생각나는 것: sizeof

### 배열과 포인터는 몹시 비슷하다.
배열은 연속된 메모리라서 전부 스택에 넣을 수 없다. 따라서 매개변수로 배열을 전달할 때는 시작 위치만 전달한다.

이때, 시작위치란 메모리 주소를 말한다.

배열은 시작 주소를 가진다.

nums[0]의 주소를 얻으려면, 주소 연산자를 사용해서 &nums[0]할 것.
> int* ptr = nums;
> 
> int* ptr2 = &nums[0];

위 둘은 동일하다.
&nums[0]=ptr=nums

- 배열 속에서 각 요소 사이의 바이트 간격이 일정하다. 
- 포인터에 정수를 더하는 것은 데이터를 n개 건너뛴다는 것이다. 

### 중간 정리
- 포인터에 들어가는 것은 주소 (배열 이름이나 주소 연산자)
- 포인터에 정수를 더하면 주소 이동
- 
## 한 바이트만 옮기고 싶다면
해당 주소에서 캐스팅 ! 
`int* int_ptr = int_array;
int_ptr = (char*)int_ptr+1;`
이 경우, char로 딱 한 바이트만 옮기게 된다. 

캐스팅해도 주소 크기는 바뀌지 않는데, 그냥 포인터 읽어오는 것만 그 크기로 한다는 것.

## 두 주소간 사칙연산
**주소에는 정수만 더하거나 뺄 수 있다.**
두 주소간 뺄셈 제외하고는 주소끼리의 연산은 불가하다. 

## 포인터변수는 안전하지 않다
기본형 제외하고는 자바나 C#에서 내부적으로 동일하게 포인터를 쓴다고 할 수 있다. 
그런데 포인터 변수를 사용하지 않는 이유는? 
주소 이동을 허가하지 않기 때문이다. 이는 안전하지 않다. 

그러나, 안전하지 않다고 해서 안 쓰기엔 너무 강력하다. 값을 복사하는 것보다 주소에 접근하는 게 훨씬 빠르기 때문이다. 

* 훌륭한 프로그래머 -> 안 쓰는 것보다는 잘 쓰도록 해야한다. 

## 포인터와 배열의 차이
1. sizeof 연산자
   - sizeof(배열) = 배열의 크기 총 바이트 수 (3*4)
   - sizeof(포인터) =포인터의 크기(3)
2. 문자열 초기화
   - c는 문자열이 없다. char 배열로 이용한다. 
   - ex. Friday 는 F/r/i/d/a/y/\0으로 표현
   - 마지막에 null 문자가 들어간다. 
   - 초기화 방법은, 
     - 배열 char day1[]= "Monday";
       - 이는 스택에 저장된다. 함수 안에서 사용하면 그 때 복사해서 스택에 넣는다. 그전에는 미리 저장된 공간이 있다.
     - char* day2 = "monday";
       - 변수는 스택에 복사되지만, monday는 스택복사되지 않고 데이터 섹션 그대로 가리킨다. 데이터 섹션에 저장됨! 
     - 스택에 저장된 문자열은 수정이 가능하지만, 데이터 섹션은 수정이되지않고 읽기 전용이다. 
3. 대입
   - 포인터 변수에 값을 대입할 수 있다. 
   - 배열 변수에는 할 수가 없다. 
4. 포인터 산술연산 ex ++pointer 
   - 포인터에 배열주소 대입 후에 가능하다. 

## 연산자 결합 법칙
우선순위 연산자를 실행한다. 대부분이 왼 -> 오로 수행되는데, 문제는 포인터 연산자다. 

포인터 연산자의 경우, 
1) ++, --(후위 연산): ->
2) ++, --(전위 연산), * : <-

애매하면 괄호를 쓰는 게 나을지도 

## 조금 더 빠른 배열의 요소 더하기 함수
포인터는 이미 다음 위치에 가 잇고, 배열은 첫 시작부터 sizeof * index를 해야한다. 

## 포인터와 const
1) 주소를 보호한다. 
포인터 변수에 const 를 붙이면 const 포인터는 메모리 주소를 바꿀 수 없다. 

오른-> 왼으로 읽어야한다. int* const p 로 읽는다.

반면에 주소를 통하여 값을 못바꾸게 하려면, 
int const* p로 해야한다. 

- 주소와 값 모두 못 바꾸게 하려면
  - const int* const p 
  - 그러나 이는 생각보다 유용하지않게 쓰인다. 전역변수나 구조체 멤버변수 정도가 유용하지. 
- 그냥 const 제거하지말것. 캐스팅도 금지

## pointer 용도?
- 큰 데이터를 함수의 매개변수로 전달할 때
- 반환값이 둘 이상일 때
  - c에서는 return 문으로 불가능
  - 포인터를 사용하면 함수 안에서 원본을 직접 변경할 수 있다.
- 동적 메모리 할당: stack 아니고, 언제 메모리 할당할거다 하는 수명을 결정할 때
- 데이터 구조 구현: 복사없이
- 임베디드에서 하드웨어 메모리에 직접 접근해야할 때

## 포인터 배열
포인터도 변수니까, 포인터를 저장하는 배열도 있다.
그렇다면 어떻게 배열을 선언해야 할까? 

포인터도 배열에 넣을 수 있다. 
> int* pointers[3];

이는 왠지 배열의 배열과 비슷. 
- 이 경우 함수에서 접근하기 위해서는, 내부 배열 길이도 알리는 size_t 베열 필요
- 

### 이건 2D 배열이랑도 비슷한거아니야? 
- 2D 배열은 한 메모리 덩어리로 저장된 것이라서 주솟값이 저장된 곳이 없다. 
- > int matrix[][10] 처럼 몇개를 건너 뛰어야하는지 컴파일러에 알릴 필요가 있다. 포인터 배열관 다르다.
