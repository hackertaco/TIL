## 필요성
- C에서 모든 data는 값형, 주소만 전달하면 참조형처럼 쓸 수 있다. 
  - 주소 전달 안되면 값형
- 사람들은 세상을 덩어리로 파악하고
- 실수도 막을 수 있다. 
- 원자성을 보장하는 연산을 사용하는 게 좋다. 

### 구조체
```c
struct date{
  int year;
  int month;
  int day;
};
```

> struct date date;

여기서 앞의 date는 구조체명, 뒤의 date는 변수명이다. 

- 구조체는 함수의 매개변수로도 사용이 가능하다. 
- 조금 더 간결하게 구조체를 정의할 수 있다. 
  - typedef 추가시
  - > typedef struct date date_t;
  - > date_t date; 로 사용
  
- 애초에
```c
typedef struct date{
int year;
int month;
int day;
}date_t;
```
```c
typedef struct {
int year;
int month;
int day;
}date_t;
```

위의 두 방식으로도 사용 가능하다. 

---
### 구조체 변수 초기화하기
date.year = 0...도 가능하고
date_t date = { 0, } 도 가능하다.
- 아예 요소나열법을 통해서도 date_t date = {1,2,3} 가능하지만, 이 경우 누군가가 구조 바꾸었다면 반영이 힘들다. 

### 구조체 매개변수
인자를 전달하는데, 이는 값형으로 전달하는 것이다. 원본을 바꾸려면 주소 전달을 해야한다. 
```c
date_t* date로 전달받으면
(*date).year = (*date).year+1;
date->year = date-> year+1;
```

- 구조체의 경우 멤버변수 너무 많을 때, 주소로 전달하는 게 공간이 훨씬 덜 나온다. 
- 포인터에 const 넣으면 원본 변경이 안된다. 
- 매개변수를 구조체로 전달하는 것과 개별 매개변수로 전달하는 것 중 선택하는 데에 정확한 기준은 없지만 보통은 구조체로 전달한다. 

---
### 함수 반환값
- 복사에 의한 반환이다.
- 대입도 된다. memcopy 사용시 메모리 통째로 복사해준다.

### 얕은 복사 , 깊은 복사
- 포인터만 복사하는 것: 얕은 복사
- 깊은 복사: 대입만으로는 안되고 동적 메모리 할당 필료

### 포인터 저장의 문제
구조체 내의 데이터는 포인터가 없는 게 좋다. 대입, 저장할 때! 

## 구조체를 다른 구조체의 멤버로 사용
- 시스템마다 메모리에 접근할 때, 사용하는 주소에 대한 요구사항이 다르다. 
  - 시스템 상의 제약
  - 효율성 두가지 이유 때문
- x86 시스템은 4바이트(워드 크기) 경계에서 읽어오는 게 효율적이다
  - 4바이트 경계에 정렬된다. 

### 바이트 정렬
`unsigned short height;
float weight;
unsigned short age;`

와
`unsigned short height;
unsigned short age;
float weight;
`
은 서로 크기가 다르다. 위의 것이 크기가 더 크다. 그 이유는 패딩 때문이다. 
#pragma pack을 통하여, 패킹을 해줄 수는 잇지만, 잘 못 쓴다. 
- 어쩔 수 없이 패딩이 생길거라면 구조체에 패딩을 명시적으로 넣는 방법도 있다. (워드 크기 맞추기 위해)

## 비트 필드
```c
typedef struct {
  unsigned char b0:1;
  ...
}bitflags_t;
```

- 구조체로 크기를 자유자재로 조정 할 수 있다. (비트 플래그라 볼 수 있음)
- 해당 구조체의 내부는 비트로 쪼개진 것이다. 
- 그러나 전체를 한번에 체크하기란 어렵다. 포인터로 할 수는 있지만 실수할 가능성이 높다. 이를 해결하기 위해 공용체를 사용해볼 수 있다.

## 공용체
구조체와 비슷하지만 구조체 내의 변수를 서로 다르게 해석하고 싶을 때 사용한다. 
```c
typedef union{
  unsigned char val;
  struct {
    unsigned char b0:1;
    ,,,
  }bits
}bitflags_t;
```

위의 val과 bits는 같은 공간을 공유한다. 동일한 메모리를 두개의 다른 자료형으로 접근하는 것이고, 메모리 값은 동일하다. 
- 메모리 공유만을 위한 공용체는, 실수가 생길 수도 있고, 덜 유용하다. 

