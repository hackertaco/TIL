## 필요성
- C에서 모든 data는 값형, 주소만 전달하면 참조형처럼 쓸 수 있다. 
  - 주소 전달 안되면 값형
- 사람들은 세상을 덩어리로 파악하고
- 실수도 막을 수 있다. 
- 원자성을 보장하는 연산을 사용하는 게 좋다. 

### 구조체
```c
struct date{
  int year;
  int month;
  int day;
};
```

> struct date date;

여기서 앞의 date는 구조체명, 뒤의 date는 변수명이다. 

- 구조체는 함수의 매개변수로도 사용이 가능하다. 
- 조금 더 간결하게 구조체를 정의할 수 있다. 
  - typedef 추가시
  - > typedef struct date date_t;
  - > date_t date; 로 사용
  
- 애초에
```c
typedef struct date{
int year;
int month;
int day;
}date_t;
```
```c
typedef struct {
int year;
int month;
int day;
}date_t;
```

위의 두 방식으로도 사용 가능하다. 

---
### 구조체 변수 초기화하기
date.year = 0...도 가능하고
date_t date = { 0, } 도 가능하다.
- 아예 요소나열법을 통해서도 date_t date = {1,2,3} 가능하지만, 이 경우 누군가가 구조 바꾸었다면 반영이 힘들다. 

### 구조체 매개변수
인자를 전달하는데, 이는 값형으로 전달하는 것이다. 원본을 바꾸려면 주소 전달을 해야한다. 
```c
date_t* date로 전달받으면
(*date).year = (*date).year+1;
date->year = date-> year+1;
```

- 구조체의 경우 멤버변수 너무 많을 때, 주소로 전달하는 게 공간이 훨씬 덜 나온다. 
- 포인터에 const 넣으면 원본 변경이 안된다. 
- 매개변수를 구조체로 전달하는 것과 개별 매개변수로 전달하는 것 중 선택하는 데에 정확한 기준은 없지만 보통은 구조체로 전달한다. 

---
### 함수 반환값
- 복사에 의한 반환이다.
- 대입도 된다. memcopy 사용시 메모리 통째로 복사해준다.

### 얕은 복사 , 깊은 복사
- 포인터만 복사하는 것: 얕은 복사
- 깊은 복사: 대입만으로는 안되고 동적 메모리 할당 필료

### 포인터 저장의 문제
구조체 내의 데이터는 포인터가 없는 게 좋다. 대입, 저장할 때! 

