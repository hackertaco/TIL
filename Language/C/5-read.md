어떤 데이터가 들어올지 몰라서 읽기는 까다롭다.
## 한 글자씩 읽기
- 버퍼로부터 한 글자를 읽어온다. 
- getchar()
- 키보드로부터 문자를 읽어서 int형 반환. 굉장히 많은 입출력 함수가 char가 아닌 int를 사용한다. 
- 반환값? 성공이면 문자, 실패면 EOF 반환
### 알고리듬
`c = getchar()
while(c!= EOF){
    purchar(c)
    c = getchar();
}`
EOF는 ctrl + z ||  ctrl+ d

한 글자씩 읽는 방법은 가장 간단한 입력 방법이고, 메모리에 입력값을 저장안해둬도 된다. 

### 언제 쓰면 좋은지
for문 한번만 도는 알고리듬에 적합
그러나 다른 데이터형으로 쓰긴 좀 어렵다.
![img_10.png](img_10.png)

### 공백과 줄 수 세기 
공백: \n, ' '

## 한 줄씩 읽기: 생각보다 몹시 유용하다. 
- 한 줄을 읽어오면 어디에 저장하는가
  - strstr()처럼 새로 반환 -> 메모리 누수의 가능성
    - 그래서, 프로그래머가 미리 받은 배열을 전달한다. 
- char* gets(char* str);
  - 이는 stdin 에서 계속 글자를 읽고 str에 저장하게된다. 
  - 성공시 str, 실패시 null pointer를 반환한다. 
  - 이는 매우매우 위험하여 c11에서는 아예 제거가 되었다.
    - 이유는 64자 이상 입력시 버퍼 오버플로가 나타나고, 늘린다해도 통제가 불가하다. 
    - 돌아갈 함수 주소까지 바꾸어버릴수도 있다. 
    - 버퍼 overflow가 가능하다. 
- char* fgets(char* str, int count, FILE* stream);
  - stdio.h
  - 최대 count-1개의 문자열
  - 새 줄을 만나지 않아도 이 함수가 반환 가능
    - 그래서 새 줄 문자인 \n이 들어감
- 한 줄씩 읽는 게 유용한 경우
  - cpu 안에서 한번에 읽어오는 게 더 빠름

## 한 데이터씩 읽기
- printf() <> scanf()
1) scanf: stdin scanf("%d", &num);
2) fscanf(): stream
3) sscanf: 문자열 버퍼 

- scanf의 서식 문자열
  - 공백 문자는 버린다. 넣고 싶으면 %c로 구분
  - %s의 경우, 너비 지정 안하면 버퍼 오버플로
- scanf 사용례 
  - 굉장히 이상하다. 그래서 사용례를 알아야한다. 
- scanf 문제
  - 여전히 버퍼 오버플로우가 가능하여 문자열에는 별로다. fgets랑 같이 사용해야한다. 
- 한 파일 읽기가 유용한 경우는 텍스트 다른 자료형으로 곧바로 읽어오는 간단한 방법이다. 

## 한 블록씩 읽기
>fread(void* buffer, sieze_t size, size_t count, FILE* stream)

이는 이진 데이터 반환, 시스템 달라지면 적용이 힘들다. 

## 파일 입출력
1) 파일 열기
   - fopen("txt", "r")
   - +b를 붙이면 이진 모드로 파일을 연다.

2) 파일 쓰기 
   - 버퍼를 사용할 경우, 버퍼링 때문에 바로 파일에 저장되지 않음. 
   - \n을 사용하거나 fflush. 근데 \n을 \n으로 인식하지 못한다.
3) 파일 닫기
   - 닫지 않으면 큰 문제가 된다. 닫으면 0, 실패시 EOF
4) 파일이 없으면
   - 널 포인터 반환. 
5) 실패한 이유 알고싶다면, errno -> 숫자로 표현 

   - strerror(errno) 에러코드 넣으면 에러 메세지 출력 perror(const char* s) : 내부적 문제 까지 알려준다. 