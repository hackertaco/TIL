## 함수 포인터 
함수도 매개변수로 전달할 수 있을 방법
해당 함수의 시작 주소를 기억하면 된다. 

함수를 호출할 떄는 직접 함수명을 쓴다. 
그런데, 어셈블리어로는 그 함수의 주소로 점프하게된다. 
즉 결국 메모리 주소가 필요하다.

- 돌아갈 주소는 스택 메모리에 저장되어있었고
  - 돌아갈 주소가 스택에 들어있다는 의미는 실행 도중에 해당 주소가 결정된다는 것이다. 
  - 함수가 시작하는 주소를 저장해두어야한다.

### 함수를 매개변수로 전달할 때 필요한 것들
함수 포인터(함수가 시작하는 주소)를 매개변수로 전달하면 된다는 것은 알겠는데..
function 이라는 자료형은 없다.
함수를 호출하려면 어떤 형의 매개변수를 몇 개나 스택 메모리에 넣어주어야하는지도 모르고 반환값이 있는지 있다면 어떻게 가져다 써야하는지도 모른다.

다양한 모습의 함수를 하나의 자료형으로 표현하는 것은 쉽지 않다. 
- 매개 변수 목록
- 반환형
모두 가지고 있어야 하는 함수 포인터.


### 함수 포인터의 선언과 사용
```c
double (*func)(double, double) = add;
result = func(op1, op2);
```
- func는 변수 이름
- 앞의 double은 반환형
- 괄호 안 double 들은 매개변수
- 그리고 add를 이 함수 포인터 변수에 대입한다.
### 함수 포인터 매개변수 선언과 사용
```c
<.h>파일
double calculate(double, double, (*)(double, double));

<.c>파일
double calculate(double x, double y, double (*func)(double, double)){
    return func(x, y);
}

```

## 함수 포인터 읽기
오른쪽-왼쪽 규칙
1. 함수 변수명을 먼저 확인하고, 왼쪽으로 움직이다가 ) 괄호에 부딪히면
2. 왼쪽으로 이동한다. *를 보고 포인터라는 것를 인식하고, (괄호에 다시 튕기게된다. 
3. 오른쪽으로 또 가는데, 이번에는 ) 괄호를 지나쳐서 매개변수를 확인한다. 끝까지 가서 다시 왼쪽으로 간다. 
4. 이번에는 함수의 반환형을 확인한다. 


## 배열 포인터
배열 전체 다 가리키는 포인터
- 잘 안쓰고, 2차원 배열을 매개변수로 받을 때 쓸 수 있다. 
- arr[1][2] == *(*(arr+1) + 2)
```c
int scores[3] = {1, 2, 3};
int(*p)[3] = &scores;
```
## 함수 포인터 예: 퀵 정렬

```c
void qsort(void *ptr, size_t count, size_t size, int(*comp)(const void*, const void*))
```
- 어떤 데이터라도 처리가 가능하다. 
  - ㄷㅐ신 그 기준에 맞는 정렬함수를 세번째 인자인 함수 포인터로 전달 필요.
- O(NlogN)

## void* 
- 범용적 포인터
- 어떤 포인터라도 대입이 가능하다. 
- 역참조는 어떤 데이터를 가져올지 모르기 때문에 안되고
- 포인터 산술 연산도 안된다. 다른 포인터로 캐스팅이 필요하다.
