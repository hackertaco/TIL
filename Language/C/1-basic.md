### printf()
- 화면에 데이터 출력시 사용
- f는, formatted의 약자다. 
- 즉 예쁘게 정렬맞춰 출력한다는 뜻이다. 

> const char* name = "BloodyMary";
> 
> printf("Hello, %s\n", name);

- %s라는 서식문자가 문자열이 들어갈 위치를 알려준다. 
- C#보다 훨씬 불친절..
- 정수는 %d

### 주석
/* */만 지원한다! (최소한 C89에선)

### C 개괄
C는 절차적 언어다. 순수하게 절차적 언어로만 사용이 가능하다. 

즉, 데이터보타 프로세스에 중점이 맞춰져있다. 
반드시 나쁜 것도 아니고, 이해하기도 쉽다.

컴퓨터가 작동하는 것을 그대로 따라하는 것이기 때문에, 추상적인 개념인 개체지향보다 논쟁 거리가 따로 없다.

- 클래스도 없고, 함수도 전역함수, 변수도 함수 밖에 선언되어있으면 전역, 안에 선언되어있으면 지역변수.

### C의 자료형
unsigned라는 단어를 자료형 이름 앞에 넣어줘야한다.ex.unsigned char
- signed를 명확히 하기위해 붙여줄 수도 있다. 근데, unsigned/signed를 생략하면 부호 있는게 기본이다. 

- char
  - 최소 8비트인 정수형
  - 웬 최소? 8비트 이상이라고만 정의하는 C..
  - 컴파일러 제멋대로 1백만 비트도 가능하다.
  
그렇다면, 몇 비트인지 찾는 방법
> #include <limits.h>

헤더 인클루드 한 뒤에, CHAR_BIT을 보면 알 수 있다. 

char는 이 기계에서 도는 가장 작은 메모리고, C 표준은 기본 자료형의 정확한 바이트 수를 강요하지 않는다. 
바이트는 char의 크기. 
하드웨어마다 표준이 다를 수 있기 때문에 표준을 명확히 세우지 않았다. 

char에 기본 부호가 지정이 안되어있다. 
부호 여부를 판단하려면? <limits.h> 에서 CHAR_MIN을 보면된다. 

![img.png](img.png)
- 근데 왜 signed char가 -128이 아닌가? 
  - 아주 옛날 기계는 1의 보수를 쓸지도 모르기 때문에, 안정적으로 처리
  - 안전한 포팅을 위해

실제로 그러나 개발할 경우 안전히 생각해도 되는 것
1. 크기: 8비트
2. 부호를 생략할 경우: signed


- short
  - 최소 16비트, char의 크기 이상이다.
  - 메모리를 적게 쓰기 위해 사용하지만, int 대신 short 사용하면 성능이 느려질수도. cpu가 신경써줘야해서.

- int
  - 최소 16비트, short 크기 이상!
  - cpu의 레지스터 크기에 맞추고, 그 데이터를 워드 크기라 한다. 워드 크기 = 레지스터 크기
  - 16비트 cpu가 예전에는 흔했다. 그래서 최소 16비트라고 한다. 
  - cpu에게 앞뒤 생략하고 정수 처리하라고 하면 그냥 말을 들었다. 
  - 지금 32비트 컴퓨터가 나와서 int 크기는 32비트가 되었다.
    - 지금은 64비트인데? 그래도 32비트. 
    - 너무 오랫동안 32비트를 int의 크기로 사용해서. 바꾸기 애매하다.
    - 성능이 무조건 빨라지지도 않는다 64비트로 바꿔도.
    
  - 표준은 short와 같다. (포팅의 안전한 범위가)
  - int의 리터럴
    - 리터럴: u, U 모두 가능. 부호 없는 수를 표현

- long
  - 최소 32비트고, int 이상의 크기
    - 최소 64비트인 정수형? C89에는 없다. 
    - 표준에 상관없이 보통 안전하게 생각해도 되는 것: int와 같다. 
  - 리터럴: l을 붙이는 경우가 잇다. ul 로 unsigned+long 의미를 줄 수도 있다. 
    - 없으면 경고가 나온다. 
---

- float
  - 표준에 따르면 IEEE 754일수도 아닐수도.
  - 크기는 char 이상이면 된다. 
  - unsigned 형 없다. 
  - 보통 안전히 생각해도 되는 것은 32비트 된다. 
- double
  - cpu가 계산에 사용하는 기본 데이터 크기
  - 크기는 float 이상이면 된다. 
  - unsigned형 없다. 
  - 표준에 상관없이 안전하게 생각해도 되는 건 64비트
- long double
  - double보다 정밀도가 높다. 
  - double 이상의 크기면 된다. 
  - unsigned형 없다. 
  - 생각보다 잘 안쓴다. 

데스크톱에서는 다른 언어와 비슷하게 사용 가능하다. (예외: long: 32비트) 소형 기기 다룰 때는 자료형 크기 확인 후 사용할 것! 