## C 스타일 문자열
### 문자열의 표현과 길이
기본자료형과의 차이? 크기나 범위가 고정되어있지 않다. 
pizza나 ham의 길이를 서로 다르게 처리하여야할까? 즉 컴퓨터와 나 사이 규칙을 만들기가 영 어렵다. 
> 그래서 문자열을 어떻게 표현할까?
> 
> 여러개의 문자를 연결 -> 배열! char[수]로 표현

- 그런데 이에는 문제가 있었는데.. 각 배열의 길이가 저장이 되지 않아서, 따로 길이를 기억해두어야한다. 

## 문자열 관리시 길이의 문제
문자열을 바꾸고 그 배열 길이 변수는 안 바꾸면? 혹은 잘못 바꾸면? 실수가 많아질 수밖에 없다. 

### 자체적 지원 
어떻게 문자열을 만들어야 할까? 
- 1. 길이를 배열 첫 위치에 저장. 
  - 근데 이는 unsigned char로 저장하기는 짧다. 
  - 그럼 int로 저장하면 안돼? 용량낭비. 다른 언어는 그렇게 하고있다 (oop언어들. 근데 c는 oop는 아님)
- 2. 문자열이 끝나는 위치를 표시 (채택)
  - 문자열에서 유효하지 않은 문자를 적기
  - 그럼 그 특별한 문자란? 아스키 제어문자가 있는데, (0~31, 127번째에) 그 중 하나가 0, 널캐릭터라 불린다. 이는 널 포인터랑은 다름에 주의
  - > char null_char = '\0';
  - C 스타일 문자열이라하면 널 문자로 끝나는 char 배열을 말한다. 
  - char str[] = {'a','b','c'}의 경우 \0을 넣지는 않는다. 

### C스타일 문자열의 장단점
- 장점
  - 최소한의 메모리
  - 한가지 데이터형으로 문자열 길이를 다 표현
  - 길이를 잡아두고 그 하에서 유연
- 단점
  - 길이를 한번에 알 수가 없어서 처음부터 읽어나가야한다. 

### 그렇다면 문자열 길이를 어떻게 구할까
- char 배열 요소를 처음부터 차례로 읽는다. 
- 널 문자를 만나면 멈춘다.
- 여태까지 총 몇개의 char를 방문했는지 그 카운터를 반환한다. 
> size_t i;
> 
> for(i=0; str[i] != '\0'; ++i){
> 
> }
> 
> return i;

포인터로 개선해볼수도 있다. 

> size_t count= 0;
>
> const char* p = str;
> 
> while(*p++ != '\0){
>
> ++count;
> 
> }
>
> return count;
>


> const char* p = str;
>
> while(*p++ != '\0){
>
> }
>
> return p - str - 1;

### 사실 문자열의 길이를 구하는 함수가 있기는 하다. 
> size_t strlen(const char* str);

<string.h>를 인클루드 하면된다. 
- 그래도 포인터로 작업은 필수! 
### 가끔하는 실수들
char str[] = {'p', 'o', 'c'} -> 는 \0이 없어서 뜬금없는 수가 나올 수 있다. 
length를 char str[LENGTH] 변수로 추가해줄 때도 마찬가지.

문자열의 길이가 어떻게 될지 모르니 조심해야한다. stackoverflow가 날수도있다. 

### 두 문자열을 비교하는 것
사전식 순서를 따르게 된다. 
>while(*str0 != '\0' && *str0 == *str1){
> ++*str0;
> ++*str1;
> }
> 
> return *str0 - *str1;

- strcmp()라는 함수도 있다. 
- strncmp()는 n 파라미터를 넣어 최대 n 문자까지만 비교하게된다. 

### 문자열 합치기
> char* strcat(char* dest, const char* src);

- src 문자 dest 뒤에 덧붙임.
- <string.h> 안에 있다. 
- dest의 길이가 넘지않게 주의해야한다. 
- 더 안전하게 strncat()으로 파라미터값을 count를 넣어주어서, 최대 count+1개의 문자를 덮어쓰게 할 수 있다. 
- 간단히 dest_count - strlen(dest) - 1로 카운트 변수를 설정해주어도 된다.


