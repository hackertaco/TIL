## C 스타일 문자열
### 문자열의 표현과 길이
기본자료형과의 차이? 크기나 범위가 고정되어있지 않다. 
pizza나 ham의 길이를 서로 다르게 처리하여야할까? 즉 컴퓨터와 나 사이 규칙을 만들기가 영 어렵다. 
> 그래서 문자열을 어떻게 표현할까?
> 
> 여러개의 문자를 연결 -> 배열! char[수]로 표현

- 그런데 이에는 문제가 있었는데.. 각 배열의 길이가 저장이 되지 않아서, 따로 길이를 기억해두어야한다. 

## 문자열 관리시 길이의 문제
문자열을 바꾸고 그 배열 길이 변수는 안 바꾸면? 혹은 잘못 바꾸면? 실수가 많아질 수밖에 없다. 

### 자체적 지원 
어떻게 문자열을 만들어야 할까? 
- 1. 길이를 배열 첫 위치에 저장. 
  - 근데 이는 unsigned char로 저장하기는 unsigned char가 너무 짧다. (최대 255글자) 
  - 그럼 int로 저장하면 안돼? 용량낭비. 다른 언어는 그렇게 하고있다 (oop언어들. 근데 c는 oop는 아님)
    - 더군다나, 순수 C 코드로 어떻게 작성을 해야할지 애매하다. 
    - 첫 데이터는 int* 로 캐스팅하고 그 다음부터는 char*로 읽어야..
  2. 문자열이 끝나는 위치를 표시 (채택)
  - 문자열에서 유효하지 않은 문자를 적기
  - 그럼 그 특별한 문자란? 아스키 제어문자가 있는데, (0~31, 127번째에) 그 중 하나가 0, 널캐릭터라 불린다. 이는 널 포인터랑은 다름에 주의
  - > char null_char = '\0';
  - \는 이스케이프 문자
  - char null_char = 0; 으로 작성 가능! 
  - C 스타일 문자열이라하면 널 문자로 끝나는 char 배열을 말한다. 
  - char str[] = {'a','b','c'}의 경우 \0을 넣지는 않는다. 
  - char str1[] = "abc" -> 스택에 저장, 알아서 \0 넣어준다.
  - char* str2 = "abc" -> data 섹션에 저장, 알아서 \0 넣어준다.

### C스타일 문자열의 장단점
- 장점
  - 최소한의 메모리
  - 한가지 데이터형으로 문자열 길이를 다 표현
  - 길이를 잡아두고 그 하에서 유연
- 단점
  - 길이를 한번에 알 수가 없어서 처음부터 읽어나가야한다. 

### 그렇다면 문자열 길이를 어떻게 구할까
- char 배열 요소를 처음부터 차례로 읽는다. 
- 널 문자를 만나면 멈춘다.
- 여태까지 총 몇개의 char를 방문했는지 그 카운터를 반환한다. 
> size_t i;
> 
> for(i=0; str[i] != '\0'; ++i){
> 
> }
> 
> return i;

포인터로 개선해볼수도 있다. 

> size_t count= 0;
>
> const char* p = str;
> 
> while(*p++ != '\0){
>
> ++count;
> 
> }
>
> return count;
>


> const char* p = str;
>
> while(*p++ != '\0){
>
> }
>
> return p - str - 1;

### 사실 문자열의 길이를 구하는 함수가 있기는 하다. 
> size_t strlen(const char* str);

<string.h>를 인클루드 하면된다. 
- 그래도 포인터로 작업은 필수! 
### 가끔하는 실수들
char str[] = {'p', 'o', 'c'} -> 는 \0이 없어서 뜬금없는 수가 나올 수 있다. 
length를 char str[LENGTH] 변수로 추가해줄 때도 마찬가지.

문자열의 길이가 어떻게 될지 모르니 조심해야한다. stackoverflow가 날수도있다. 

### 두 문자열을 비교하는 것
사전식 순서를 따르게 된다. 

```C
int compare_string(const char* str0, const char* str1);
```
>while(*str0 != '\0' && *str0 == *str1){
> ++*str0;
> ++*str1;
> }
> 
> return *str0 - *str1;

- strcmp()라는 함수도 있다. 
- strncmp()는 n 파라미터를 넣어 최대 n 문자까지만 비교하게된다. 
### 문자열 복사
```C
void copy_string(char* dest, const char* src)
{
  while(*src != '\0'){
    *dest++ = *src++;
  }
  
  *dest = '\0';
}
```
> char* strcpy(char* dest, const char* src);

- dest 를 반환
- 아무도 안쓴다. dest 가 src 보다 짧으면?? 범위 넘어서서 계속 복사한다. 그래서 문제가 있다. 
- strncpy()가 비교적 안전하다. count 매개변수가 하나 더 들어가서, 그 이상/이하 로 들어오는 src 문자를 제어해준다.
- C11 에서 나온 strcpy_s()
### 문자열 합치기
> char* strcat(char* dest, const char* src);

- src 문자 dest 뒤에 덧붙임.
- <string.h> 안에 있다. 
- dest의 길이가 넘지않게 주의해야한다. 
- 더 안전하게 strncat()으로 파라미터값을 count를 넣어주어서, 최대 count+1개의 문자를 덮어쓰게 할 수 있다.
  - 근데 이마저도 만약 src > count면, 널문자를 안 넣어줘서 굳이 코드 한줄을 추가해야한다. 
- 간단히 dest_count - strlen(dest) - 1로 카운트 변수를 설정해주어도 된다.


### 문자열 찾기
- 없는 문자열을 찾게되었을 때 
  - null pointer를 출력하게 되면 안전하지않다. 컴파일러에 따라 터질수도 있기 때문이다. 
  > null? "null": result;
- 존재하는 문자열을 찾으면? 
- string 찾은 위치부터 시작하는 전체 문자열을 반환해버린다. 
- 포인터를 그 위치에 옮기고 그 이후부터 반환하는 것
> char* strstr(const char* str, const char* substr);
- <string.h> 포함
- 반환값은 char 포인터
- 이것을 쓰면, 메모리접근에서 const char로 매개변수를 주었음에도 값을 바꾸는 것의 애매함이 있다. 

### 문자열 찾기 함수가 메모리 주소를 반환하는 이유
- C이기 때문이다. 새로운 문자를 만들면 메모리 관리와 속도가 저하되는 문제가 있다. 
  - 지우는 것을 까먹거나, (heap으로 동적 메모리 할당시)
  - stack이라면, 주소가 유효하지 않다거나.
- 주소 반환시 실수가 적은 방법? 
  - 원본에서 찾고자하는 문자열의 시작주소 반환으로 해결
  - 추가적으로 메모리를 쓰지 않고, 사람이 저지를 실수도 줄일 수 있다. 

### 문자열 토큰화
> strtok(input, 구분문자)
- 구분 문자를 널 문자로 바꿔서 반환한다.
- input의 다음 토큰을 구하려면 strtok(null, 구분문자)
더이상 토큰이 없으면 null을 반환한다. 
```C
char msg[] = "Hi, there. Hello. Bye.";
const char delims[] = ",. ";
char* token = strtok(msg, delims);

  while(token != NULL){
    token = strtok(NULL, delims);
  }
```
- 함수 매개변수로 널이 들어올 때 그전에 받았던 msg를 사용하니 이건 어딘가에 저장되어있어야하는데, 
  - 함수 내 정적 변수(데이터 섹션)가 적합
  - 
## 문자열 함수의 특징
- 문자열을 절대 변경하지 않는다. 
- 변경하더라도 원본은 변경하지않는다. 예외가 있다면 strtok
- 새로운 문자열을 만들어주지 않는다. 

##