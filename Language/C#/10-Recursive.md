## 재귀 함수
이미 해결한 작은 문제를 반복해 더 큰 문제를 해결하는 방법.

프로그래밍 개념: 함수 A가 매개변수만 바꾸어 함수 A를 호출하는 방법으로 구현

### 구성 요소
- 종료 조건
  - 더 이상 재귀함수를 호출하지 않고 값을 반환하는 조건
  - 매우 간단히 함수의 반환값을 찾을 수 있는 경우
  - 종료 조건이 없으면 무한으로 돌아갈 수가 있다. -> 스택오버플로우 
- 재귀적 함수 호출
  - 종료 조건이 아닌 경우
  - 함수의 인자를 바꾸어 스스로를 다시 호출
  - 현재 문제보다 작은 문제를 대표해야한다. 

### 반복문과의 비교
사실 모든 재귀함수는 반복문으로 해결 가능
그러나, 복잡한 문제일수록 재귀함수가 더 편하다!

### 재귀-피보나치 수열

```
public statc int FibonacciRecursive(uint number){
// early exit (사람의 두뇌와 비슷해진다)
    if(number == 0)
    {
        return 0;
    }
    if(number == 1
    {
        return 1;
    }
    return FibonacciRecursive(number-2) + FibonacciRecursive(number-1);
}

```

- 함수는 신뢰의 문제. 재귀 함수는 더 큰 신뢰를 요구한다. 
- 반드시 올바른 값을 반환한다고 믿어야한다. 
- 종료 조건을 잘 만들어놓으면, 그 조건에 기초하여 값을 계산 가능
- 훈련을 통해 작게 쪼개는 법을 배워야한다.

### 수학적 귀납법으로 이해하는 재귀함수
- 매우 큰 문제를 작게 쪼개서 증명할 수 있나?
- 일단 결론이 맞다고 가정하고, 그 다음 단계가 만족하는지 증명한다.

### 재귀-하노이의 탑
- 가장 작은 범위까지가 가능하면, 되는 것

### 재귀함수의 장-단점
- 개념적으로 매우 훌륭
- 증명이 가능
- 효율성이 떨어짐. 
- 반복문은 이전 연산의 결과를 저장해 효율성이 떨어질 일이 없다.
- 함수 호출 깊이에는 제한이 있다. -> 스택오버플로우
- 
### 베스트 프랙티스
- 캐싱없이 간단한 반복문으로 작성 가능한 문제는 반복문으로
- 그 외에는 재귀 함수로 우선 작성
- 함수 호출의 최대 깊이를 확정할 수 없거나, 성능상의 문제를 발견했을 때는 반복문으로 코드를 리팩토링할 것


