개체를 생성 후에, 깜박하고 데이터를 대입하지 않을 경우 예기치 못한 문제가 발생할 수 있다.

-> 이를 해결하는 것이 생성자. 더 안전하게 oop 사용 가능
 
> public Car(int price)
> { Price = price; }

여기서 매개변수 안 넣으면 컴파일 오류가 난다.

- 생성자 개체를 생성할 때 반드시 호출되는 함수
- 함수명으로 클래스명을 쓴다.
- 반환형을 아예 적지 않는다. 
- 생성에 필요한 매개변수를 강제할 수 잇다. 
- 생성자가 여럿이어도 된다.
- 생성자 오버로딩

만약, 그냥 멤버변수가 같은 값을 가지는 경우에는
애초에 생성자 안에서 상수를 바로 대입한다.
아니면 변수 자체에 대입.

멤버변수는 기본으로 0이다.
참조형은 null이다. 
- 멤버 변수일 때만 초기화 생략 가능.

### 접근제어자
바뀌면 안되는 멤버 변수의 기본값이, 개체 생성 후에 변경되는 경우! 
외부에서 변경하지 못하게끔 하려면? **접근 제어자** 사용

- public
  - 누구라도 접근 가능
    - 클래스 내외로
- private
  - 클래스 안에서만 접근이 가능하다. 
  - 변수나 함수 모두 private 가능하다! 
- protected
- internal

근데, public도 아니고 private한 것도 아닐 경우? 

예를 들면 멤버 변수가 private인데, 그럼 클래스 바깥에서는 값을 확인을 못한다.

-> 읽기가 안되는 문제

조건을 걸기가 어렵다. 
-> 그냥 public이면 조건을 못지킬수도 있다.

- 일반적인 해결법은 getter/setter 함
  - 멤버 함수로 get, set 함수를 만드는 것이다. 

> public getGas(){ return private 변수 ;}

- 순수하게 대입을 하거나, 순수하게 반환하는 걸 getter/setter 함수라 한다.

#### 그런데 굳이? 다 이렇게 함수? 변수 접근하는 건데? 
좀 더 나은 방법? **프로퍼티**!

```typescript
public int Price
{
    get
    {
        return Price;
    }
    set
    {
        if(value >=505050)
        {
            Price = value;
        }
    }
}
```

- 변수와 메서드가 모두 함께 있는 형태!
- 이는 getter, setter를 정의하는 것이라 보면 된다. 
- 컴파일러가 알아서 getter, setter 함수를 만들어 주는 것이다. 
- 추가적인 논리 코드도 넣을 수 있다. 

- 자동으로 프로퍼티를 구현하기도 ! 

> public string Owner {get; set;}
> 
> public float Gas { get; private set; } = 10.0f;

- 컴파일러가 컴파일 시 익명의 멤버 변수를 만들어 줌.
- get과 set에도 접근 제어자를 붙여줄 수 있음.
- 메ㅁ버 변수에 단순히 데이터를 대입하거나 반환만 할 때 사용
  - 로직은 수동 프로퍼티 사용해야한다.

